!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AND_THEN	.\catch.hpp	10480;"	d
AND_WHEN	.\catch.hpp	10478;"	d
AllOf	.\catch.hpp	/^            AllOf( AllOf const& other ) : m_matchers( other.m_matchers ) {}$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( AllOf const& other )
AllOf	.\catch.hpp	/^            AllOf() {}$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:()
AllOf	.\catch.hpp	/^        class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic	inherits:MatcherImpl
AllOf	.\catch.hpp	/^    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2 )
AllOf	.\catch.hpp	/^    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2, Impl::Matcher<ExpressionT> const& m3 )
AnyOf	.\catch.hpp	/^            AnyOf( AnyOf const& other ) : m_matchers( other.m_matchers ) {}$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( AnyOf const& other )
AnyOf	.\catch.hpp	/^            AnyOf() {}$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:()
AnyOf	.\catch.hpp	/^        class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic	inherits:MatcherImpl
AnyOf	.\catch.hpp	/^    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2 )
AnyOf	.\catch.hpp	/^    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2, Impl::Matcher<ExpressionT> const& m3 )
AssertionInfo	.\catch.hpp	/^        AssertionInfo(  std::string const& _macroName,$/;"	p	struct:Catch::AssertionInfo	access:public	signature:( std::string const& _macroName, SourceLineInfo const& _lineInfo, std::string const& _capturedExpression, ResultDisposition::Flags _resultDisposition )
AssertionInfo	.\catch.hpp	/^        AssertionInfo() {}$/;"	f	struct:Catch::AssertionInfo	access:public	signature:()
AssertionInfo	.\catch.hpp	/^    struct AssertionInfo$/;"	s	namespace:Catch
AssertionResult	.\catch.hpp	/^         AssertionResult( AssertionResult && )                  = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
AssertionResult	.\catch.hpp	/^         AssertionResult( AssertionResult const& )              = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
AssertionResult	.\catch.hpp	/^        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionInfo const& info, AssertionResultData const& data )
AssertionResult	.\catch.hpp	/^        AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
AssertionResult	.\catch.hpp	/^    class AssertionResult {$/;"	c	namespace:Catch
AssertionResultData	.\catch.hpp	/^        AssertionResultData() : resultType( ResultWas::Unknown ) {}$/;"	f	struct:Catch::AssertionResultData	access:public	signature:()
AssertionResultData	.\catch.hpp	/^    struct AssertionResultData$/;"	s	namespace:Catch
AutoReg	.\catch.hpp	/^    AutoReg$/;"	f	struct:Catch::AutoReg	access:public	signature:( void (C::*method)(), char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
AutoReg	.\catch.hpp	/^    AutoReg$/;"	p	struct:Catch::AutoReg	access:public	signature:( TestFunction function, SourceLineInfo const& lineInfo, NameAndDesc const& nameAndDesc )
AutoReg	.\catch.hpp	/^    AutoReg( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
AutoReg	.\catch.hpp	/^struct AutoReg {$/;"	s	namespace:Catch
BSTIterator	.\leet_173.cc	/^        BSTIterator(TreeNode *root)$/;"	f	class:BSTIterator	access:public	signature:(TreeNode *root)
BSTIterator	.\leet_173.cc	/^class BSTIterator$/;"	c	file:
BSTIterator::BSTIterator	.\leet_173.cc	/^        BSTIterator(TreeNode *root)$/;"	f	class:BSTIterator	access:public	signature:(TreeNode *root)
BSTIterator::hasNext	.\leet_173.cc	/^        bool hasNext()$/;"	f	class:BSTIterator	access:public	signature:()
BSTIterator::next	.\leet_173.cc	/^        int next()$/;"	f	class:BSTIterator	access:public	signature:()
BSTIterator::s1	.\leet_173.cc	/^        stack<TreeNode*> s1;$/;"	m	class:BSTIterator	file:	access:public
BTrie	.\wap\BTrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie	.\wap\BTrie.cc	/^		BTrie(vec v);$/;"	p	class:BTrie	file:	access:public	signature:(vec v)
BTrie	.\wap\BTrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie	.\wap\BTrie.cc	/^BTrie::BTrie(vec v):root(nullptr){$/;"	f	class:BTrie	signature:(vec v)
BTrie	.\wap\BTrie.cc	/^class BTrie{$/;"	c	file:
BTrie	.\wap\submit\BTrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie	.\wap\submit\BTrie.cc	/^		BTrie(vec v);$/;"	p	class:BTrie	file:	access:public	signature:(vec v)
BTrie	.\wap\submit\BTrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie	.\wap\submit\BTrie.cc	/^BTrie::BTrie(vec v):root(nullptr){$/;"	f	class:BTrie	signature:(vec v)
BTrie	.\wap\submit\BTrie.cc	/^class BTrie{$/;"	c	file:
BTrie	.\wap\submit\wap2_sol.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie	.\wap\submit\wap2_sol.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie	.\wap\submit\wap2_sol.cc	/^class BTrie{$/;"	c	file:
BTrie	.\wap\submit\wap_sol1.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie	.\wap\submit\wap_sol1.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie	.\wap\submit\wap_sol1.cc	/^class BTrie{$/;"	c	file:
BTrie	.\wap\submit\xortrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie	.\wap\submit\xortrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie	.\wap\submit\xortrie.cc	/^class BTrie{$/;"	c	file:
BTrie	.\wap\xortrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie	.\wap\xortrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie	.\wap\xortrie.cc	/^class BTrie{$/;"	c	file:
BTrie::BTrie	.\wap\BTrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::BTrie	.\wap\BTrie.cc	/^		BTrie(vec v);$/;"	p	class:BTrie	file:	access:public	signature:(vec v)
BTrie::BTrie	.\wap\BTrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie::BTrie	.\wap\BTrie.cc	/^BTrie::BTrie(vec v):root(nullptr){$/;"	f	class:BTrie	signature:(vec v)
BTrie::BTrie	.\wap\submit\BTrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::BTrie	.\wap\submit\BTrie.cc	/^		BTrie(vec v);$/;"	p	class:BTrie	file:	access:public	signature:(vec v)
BTrie::BTrie	.\wap\submit\BTrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie::BTrie	.\wap\submit\BTrie.cc	/^BTrie::BTrie(vec v):root(nullptr){$/;"	f	class:BTrie	signature:(vec v)
BTrie::BTrie	.\wap\submit\wap2_sol.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::BTrie	.\wap\submit\wap2_sol.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie::BTrie	.\wap\submit\wap_sol1.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::BTrie	.\wap\submit\wap_sol1.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie::BTrie	.\wap\submit\xortrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::BTrie	.\wap\submit\xortrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie::BTrie	.\wap\xortrie.cc	/^		BTrie();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::BTrie	.\wap\xortrie.cc	/^BTrie::BTrie():depth(0){$/;"	f	class:BTrie	signature:()
BTrie::clean	.\wap\BTrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::clean	.\wap\BTrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
BTrie::clean	.\wap\submit\BTrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::clean	.\wap\submit\BTrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
BTrie::clean	.\wap\submit\wap2_sol.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::clean	.\wap\submit\wap2_sol.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
BTrie::clean	.\wap\submit\wap_sol1.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::clean	.\wap\submit\wap_sol1.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
BTrie::clean	.\wap\submit\xortrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::clean	.\wap\submit\xortrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
BTrie::clean	.\wap\xortrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::clean	.\wap\xortrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
BTrie::depth	.\wap\BTrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
BTrie::depth	.\wap\submit\BTrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
BTrie::depth	.\wap\submit\wap2_sol.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
BTrie::depth	.\wap\submit\wap_sol1.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
BTrie::depth	.\wap\submit\xortrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
BTrie::depth	.\wap\xortrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
BTrie::find	.\wap\BTrie.cc	/^		bool find(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
BTrie::find	.\wap\BTrie.cc	/^bool BTrie::find(const vec &v){$/;"	f	class:BTrie	signature:(const vec &v)
BTrie::find	.\wap\submit\BTrie.cc	/^		bool find(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
BTrie::find	.\wap\submit\BTrie.cc	/^bool BTrie::find(const vec &v){$/;"	f	class:BTrie	signature:(const vec &v)
BTrie::find	.\wap\submit\wap2_sol.cc	/^		int find(const bitvec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v)
BTrie::find	.\wap\submit\wap2_sol.cc	/^int BTrie::find(const bitvec &v){$/;"	f	class:BTrie	signature:(const bitvec &v)
BTrie::find	.\wap\submit\wap_sol1.cc	/^		bool find(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
BTrie::find	.\wap\submit\wap_sol1.cc	/^bool BTrie::find(const vec &v){$/;"	f	class:BTrie	signature:(const vec &v)
BTrie::find	.\wap\submit\xortrie.cc	/^		int find(const bitvec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v)
BTrie::find	.\wap\submit\xortrie.cc	/^int BTrie::find(const bitvec &v){$/;"	f	class:BTrie	signature:(const bitvec &v)
BTrie::find	.\wap\xortrie.cc	/^		int find(const bitvec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v)
BTrie::find	.\wap\xortrie.cc	/^int BTrie::find(const bitvec &v){$/;"	f	class:BTrie	signature:(const bitvec &v)
BTrie::get_max_count	.\wap\BTrie.cc	/^        int  get_max_count(int i){$/;"	f	class:BTrie	access:public	signature:(int i)
BTrie::get_max_count	.\wap\submit\BTrie.cc	/^        int  get_max_count(int i){$/;"	f	class:BTrie	access:public	signature:(int i)
BTrie::get_max_count	.\wap\submit\wap_sol1.cc	/^        int  get_max_count(int i){$/;"	f	class:BTrie	access:public	signature:(int i)
BTrie::insert	.\wap\BTrie.cc	/^		void insert(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
BTrie::insert	.\wap\BTrie.cc	/^		void insert(const vec &v, const vec &order);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v, const vec &order)
BTrie::insert	.\wap\BTrie.cc	/^void BTrie::insert(const vec &a){$/;"	f	class:BTrie	signature:(const vec &a)
BTrie::insert	.\wap\BTrie.cc	/^void BTrie::insert(const vec &a, const vec &order){$/;"	f	class:BTrie	signature:(const vec &a, const vec &order)
BTrie::insert	.\wap\submit\BTrie.cc	/^		void insert(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
BTrie::insert	.\wap\submit\BTrie.cc	/^		void insert(const vec &v, const vec &order);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v, const vec &order)
BTrie::insert	.\wap\submit\BTrie.cc	/^void BTrie::insert(const vec &a){$/;"	f	class:BTrie	signature:(const vec &a)
BTrie::insert	.\wap\submit\BTrie.cc	/^void BTrie::insert(const vec &a, const vec &order){$/;"	f	class:BTrie	signature:(const vec &a, const vec &order)
BTrie::insert	.\wap\submit\wap2_sol.cc	/^		void insert(const bitvec &v,int index);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v,int index)
BTrie::insert	.\wap\submit\wap2_sol.cc	/^void BTrie::insert(const bitvec &a,int index){$/;"	f	class:BTrie	signature:(const bitvec &a,int index)
BTrie::insert	.\wap\submit\wap_sol1.cc	/^		void insert(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
BTrie::insert	.\wap\submit\wap_sol1.cc	/^		void insert(const vec &v, const vec &order);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v, const vec &order)
BTrie::insert	.\wap\submit\wap_sol1.cc	/^void BTrie::insert(const vec &a){$/;"	f	class:BTrie	signature:(const vec &a)
BTrie::insert	.\wap\submit\wap_sol1.cc	/^void BTrie::insert(const vec &a, const vec &order){$/;"	f	class:BTrie	signature:(const vec &a, const vec &order)
BTrie::insert	.\wap\submit\xortrie.cc	/^		void insert(const bitvec &v,int index);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v,int index)
BTrie::insert	.\wap\submit\xortrie.cc	/^void BTrie::insert(const bitvec &a,int index){$/;"	f	class:BTrie	signature:(const bitvec &a,int index)
BTrie::insert	.\wap\xortrie.cc	/^		void insert(const bitvec &v,int index);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v,int index)
BTrie::insert	.\wap\xortrie.cc	/^void BTrie::insert(const bitvec &a,int index){$/;"	f	class:BTrie	signature:(const bitvec &a,int index)
BTrie::isEmpty	.\wap\BTrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::isEmpty	.\wap\BTrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
BTrie::isEmpty	.\wap\submit\BTrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::isEmpty	.\wap\submit\BTrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
BTrie::isEmpty	.\wap\submit\wap2_sol.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::isEmpty	.\wap\submit\wap2_sol.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
BTrie::isEmpty	.\wap\submit\wap_sol1.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::isEmpty	.\wap\submit\wap_sol1.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
BTrie::isEmpty	.\wap\submit\xortrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::isEmpty	.\wap\submit\xortrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
BTrie::isEmpty	.\wap\xortrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
BTrie::isEmpty	.\wap\xortrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
BTrie::max_count	.\wap\BTrie.cc	/^        vec max_count;$/;"	m	class:BTrie	file:	access:private
BTrie::max_count	.\wap\submit\BTrie.cc	/^        vec max_count;$/;"	m	class:BTrie	file:	access:private
BTrie::max_count	.\wap\submit\wap_sol1.cc	/^        vec max_count; \/\/ the max num of leaves below at each level$/;"	m	class:BTrie	file:	access:private
BTrie::remove	.\wap\BTrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
BTrie::remove	.\wap\BTrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\BTrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\BTrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\wap2_sol.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\wap2_sol.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\wap_sol1.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\wap_sol1.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\xortrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
BTrie::remove	.\wap\submit\xortrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
BTrie::remove	.\wap\xortrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
BTrie::remove	.\wap\xortrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
BTrie::root	.\wap\BTrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
BTrie::root	.\wap\submit\BTrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
BTrie::root	.\wap\submit\wap2_sol.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
BTrie::root	.\wap\submit\wap_sol1.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
BTrie::root	.\wap\submit\xortrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
BTrie::root	.\wap\xortrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
BTrie::~BTrie	.\wap\BTrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
BTrie::~BTrie	.\wap\submit\BTrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
BTrie::~BTrie	.\wap\submit\wap2_sol.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
BTrie::~BTrie	.\wap\submit\wap_sol1.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
BTrie::~BTrie	.\wap\submit\xortrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
BTrie::~BTrie	.\wap\xortrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
BTrieNode	.\wap\BTrie.cc	/^	BTrieNode(int in=0):count(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=0)
BTrieNode	.\wap\BTrie.cc	/^struct BTrieNode{$/;"	s	file:
BTrieNode	.\wap\submit\BTrie.cc	/^	BTrieNode(int in=0):count(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=0)
BTrieNode	.\wap\submit\BTrie.cc	/^struct BTrieNode{$/;"	s	file:
BTrieNode	.\wap\submit\wap2_sol.cc	/^	BTrieNode(int in=-1):index(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=-1)
BTrieNode	.\wap\submit\wap2_sol.cc	/^struct BTrieNode{$/;"	s	file:
BTrieNode	.\wap\submit\wap_sol1.cc	/^	BTrieNode(int in=0):count(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=0)
BTrieNode	.\wap\submit\wap_sol1.cc	/^struct BTrieNode{$/;"	s	file:
BTrieNode	.\wap\submit\xortrie.cc	/^	BTrieNode(int in=-1):index(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=-1)
BTrieNode	.\wap\submit\xortrie.cc	/^struct BTrieNode{$/;"	s	file:
BTrieNode	.\wap\xortrie.cc	/^	BTrieNode(int in=-1):index(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=-1)
BTrieNode	.\wap\xortrie.cc	/^struct BTrieNode{$/;"	s	file:
BTrieNode::BTrieNode	.\wap\BTrie.cc	/^	BTrieNode(int in=0):count(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=0)
BTrieNode::BTrieNode	.\wap\submit\BTrie.cc	/^	BTrieNode(int in=0):count(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=0)
BTrieNode::BTrieNode	.\wap\submit\wap2_sol.cc	/^	BTrieNode(int in=-1):index(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=-1)
BTrieNode::BTrieNode	.\wap\submit\wap_sol1.cc	/^	BTrieNode(int in=0):count(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=0)
BTrieNode::BTrieNode	.\wap\submit\xortrie.cc	/^	BTrieNode(int in=-1):index(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=-1)
BTrieNode::BTrieNode	.\wap\xortrie.cc	/^	BTrieNode(int in=-1):index(in),left(nullptr),right(nullptr){};$/;"	f	struct:BTrieNode	access:public	signature:(int in=-1)
BTrieNode::count	.\wap\BTrie.cc	/^	int count;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::count	.\wap\submit\BTrie.cc	/^	int count;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::count	.\wap\submit\wap_sol1.cc	/^	int count; \/\/ num of leaves below this node$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::index	.\wap\submit\wap2_sol.cc	/^	int index; \/\/ remember the index of leaves in the vector$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::index	.\wap\submit\xortrie.cc	/^	int index;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::index	.\wap\xortrie.cc	/^	int index;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::left	.\wap\BTrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::left	.\wap\submit\BTrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::left	.\wap\submit\wap2_sol.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::left	.\wap\submit\wap_sol1.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::left	.\wap\submit\xortrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::left	.\wap\xortrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::right	.\wap\BTrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::right	.\wap\submit\BTrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::right	.\wap\submit\wap2_sol.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::right	.\wap\submit\wap_sol1.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::right	.\wap\submit\xortrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
BTrieNode::right	.\wap\xortrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
BigNum	.\BigNum.cc	/^        BigNum();$/;"	p	class:BigNum	file:	access:public	signature:()
BigNum	.\BigNum.cc	/^        BigNum(const BigNum &rhs){$/;"	f	class:BigNum	access:public	signature:(const BigNum &rhs)
BigNum	.\BigNum.cc	/^        BigNum(const char* str);$/;"	p	class:BigNum	file:	access:public	signature:(const char* str)
BigNum	.\BigNum.cc	/^        BigNum(const int &m);$/;"	p	class:BigNum	file:	access:public	signature:(const int &m)
BigNum	.\BigNum.cc	/^        BigNum(const string &str);$/;"	p	class:BigNum	file:	access:public	signature:(const string &str)
BigNum	.\BigNum.cc	/^BigNum::BigNum(const char* str){$/;"	f	class:BigNum	signature:(const char* str)
BigNum	.\BigNum.cc	/^class BigNum{$/;"	c	file:
BigNum	.\baidu.cpp	/^	BigNum(){ len = 1;memset(a,0,sizeof(a)); }   \/\/构造函数$/;"	f	class:BigNum	access:public	signature:()
BigNum	.\baidu.cpp	/^	BigNum(const BigNum &);  \/\/拷贝构造函数$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &)
BigNum	.\baidu.cpp	/^	BigNum(const char*);     \/\/将一个字符串类型的变量转化为大数$/;"	p	class:BigNum	file:	access:public	signature:(const char*)
BigNum	.\baidu.cpp	/^	BigNum(const int);       \/\/将一个int类型的变量转化为大数$/;"	p	class:BigNum	file:	access:public	signature:(const int)
BigNum	.\baidu.cpp	/^BigNum::BigNum(const BigNum & T) : len(T.len)  \/\/拷贝构造函数$/;"	f	class:BigNum	signature:(const BigNum & T)
BigNum	.\baidu.cpp	/^BigNum::BigNum(const char*s)     \/\/将一个字符串类型的变量转化为大数$/;"	f	class:BigNum	signature:(const char*s)
BigNum	.\baidu.cpp	/^BigNum::BigNum(const int b)     \/\/将一个int类型的变量转化为大数$/;"	f	class:BigNum	signature:(const int b)
BigNum	.\baidu.cpp	/^class BigNum$/;"	c	file:
BigNum::BigNum	.\BigNum.cc	/^        BigNum();$/;"	p	class:BigNum	file:	access:public	signature:()
BigNum::BigNum	.\BigNum.cc	/^        BigNum(const BigNum &rhs){$/;"	f	class:BigNum	access:public	signature:(const BigNum &rhs)
BigNum::BigNum	.\BigNum.cc	/^        BigNum(const char* str);$/;"	p	class:BigNum	file:	access:public	signature:(const char* str)
BigNum::BigNum	.\BigNum.cc	/^        BigNum(const int &m);$/;"	p	class:BigNum	file:	access:public	signature:(const int &m)
BigNum::BigNum	.\BigNum.cc	/^        BigNum(const string &str);$/;"	p	class:BigNum	file:	access:public	signature:(const string &str)
BigNum::BigNum	.\BigNum.cc	/^BigNum::BigNum(const char* str){$/;"	f	class:BigNum	signature:(const char* str)
BigNum::BigNum	.\baidu.cpp	/^	BigNum(){ len = 1;memset(a,0,sizeof(a)); }   \/\/构造函数$/;"	f	class:BigNum	access:public	signature:()
BigNum::BigNum	.\baidu.cpp	/^	BigNum(const BigNum &);  \/\/拷贝构造函数$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &)
BigNum::BigNum	.\baidu.cpp	/^	BigNum(const char*);     \/\/将一个字符串类型的变量转化为大数$/;"	p	class:BigNum	file:	access:public	signature:(const char*)
BigNum::BigNum	.\baidu.cpp	/^	BigNum(const int);       \/\/将一个int类型的变量转化为大数$/;"	p	class:BigNum	file:	access:public	signature:(const int)
BigNum::BigNum	.\baidu.cpp	/^BigNum::BigNum(const BigNum & T) : len(T.len)  \/\/拷贝构造函数$/;"	f	class:BigNum	signature:(const BigNum & T)
BigNum::BigNum	.\baidu.cpp	/^BigNum::BigNum(const char*s)     \/\/将一个字符串类型的变量转化为大数$/;"	f	class:BigNum	signature:(const char*s)
BigNum::BigNum	.\baidu.cpp	/^BigNum::BigNum(const int b)     \/\/将一个int类型的变量转化为大数$/;"	f	class:BigNum	signature:(const int b)
BigNum::a	.\baidu.cpp	/^	int a[500];    \/\/可以控制大数的位数 $/;"	m	class:BigNum	file:	access:private
BigNum::comp	.\BigNum.cc	/^        int comp(const BigNum &rhs) const;$/;"	p	class:BigNum	file:	access:private	signature:(const BigNum &rhs) const
BigNum::comp	.\BigNum.cc	/^int BigNum::comp(const BigNum &rhs) const{$/;"	f	class:BigNum	signature:(const BigNum &rhs) const
BigNum::data	.\BigNum.cc	/^        vector<int> data;$/;"	m	class:BigNum	file:	access:private
BigNum::divmod	.\BigNum.cc	/^        pair<int,int> divmod(const BigNum &rhs) const;$/;"	p	class:BigNum	file:	access:private	signature:(const BigNum &rhs) const
BigNum::len	.\BigNum.cc	/^        int len;$/;"	m	class:BigNum	file:	access:private
BigNum::len	.\baidu.cpp	/^	int len;       \/\/大数长度$/;"	m	class:BigNum	file:	access:private
BigNum::operator %	.\baidu.cpp	/^	int    operator%(const int  &) const;    \/\/大数对一个int类型的变量进行取模运算    $/;"	p	class:BigNum	file:	access:public	signature:(const int &) const
BigNum::operator %	.\baidu.cpp	/^int BigNum::operator %(const int & b) const    \/\/大数对一个int类型的变量进行取模运算    $/;"	f	class:BigNum	signature:(const int & b) const
BigNum::operator *	.\BigNum.cc	/^        friend BigNum operator*(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator *	.\baidu.cpp	/^	BigNum operator*(const BigNum &) const;   \/\/重载乘法运算符，两个大数之间的相乘运算 $/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &) const
BigNum::operator *	.\baidu.cpp	/^BigNum BigNum::operator*(const BigNum & T) const   \/\/两个大数之间的相乘运算 $/;"	f	class:BigNum	signature:(const BigNum & T) const
BigNum::operator *=	.\BigNum.cc	/^        BigNum& operator*=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
BigNum::operator *=	.\BigNum.cc	/^BigNum& BigNum::operator*=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
BigNum::operator +	.\BigNum.cc	/^        friend BigNum operator+(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator +	.\BigNum.cc	/^        friend BigNum operator+(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &rhs)
BigNum::operator +	.\baidu.cpp	/^	BigNum operator+(const BigNum &) const;   \/\/重载加法运算符，两个大数之间的相加运算 $/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &) const
BigNum::operator +	.\baidu.cpp	/^BigNum BigNum::operator+(const BigNum & T) const   \/\/两个大数之间的相加运算$/;"	f	class:BigNum	signature:(const BigNum & T) const
BigNum::operator +=	.\BigNum.cc	/^        BigNum& operator+=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
BigNum::operator +=	.\BigNum.cc	/^BigNum& BigNum::operator+=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
BigNum::operator -	.\BigNum.cc	/^        friend BigNum operator-(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator -	.\BigNum.cc	/^        friend BigNum operator-(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &rhs)
BigNum::operator -	.\baidu.cpp	/^	BigNum operator-(const BigNum &) const;   \/\/重载减法运算符，两个大数之间的相减运算 $/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &) const
BigNum::operator -	.\baidu.cpp	/^BigNum BigNum::operator-(const BigNum & T) const   \/\/两个大数之间的相减运算 $/;"	f	class:BigNum	signature:(const BigNum & T) const
BigNum::operator -=	.\BigNum.cc	/^        BigNum& operator-=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
BigNum::operator -=	.\BigNum.cc	/^BigNum& BigNum::operator-=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
BigNum::operator /	.\BigNum.cc	/^        friend BigNum operator\/(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator /	.\baidu.cpp	/^	BigNum operator\/(const int   &) const;    \/\/重载除法运算符，大数对一个整数进行相除运算$/;"	p	class:BigNum	file:	access:public	signature:(const int &) const
BigNum::operator /	.\baidu.cpp	/^BigNum BigNum::operator\/(const int & b) const   \/\/大数对一个整数进行相除运算$/;"	f	class:BigNum	signature:(const int & b) const
BigNum::operator /=	.\BigNum.cc	/^        BigNum& operator\/=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
BigNum::operator /=	.\BigNum.cc	/^BigNum& BigNum::operator\/=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
BigNum::operator <	.\BigNum.cc	/^        friend bool operator<(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator <<	.\BigNum.cc	/^        friend ostream& operator<<(ostream& os,const BigNum &obj);$/;"	p	class:BigNum	file:	access:friend	signature:(ostream& os,const BigNum &obj)
BigNum::operator <<	.\baidu.cpp	/^	friend ostream& operator<<(ostream&,  BigNum&);   \/\/重载输出运算符$/;"	p	class:BigNum	file:	access:friend	signature:(ostream&, BigNum&)
BigNum::operator <=	.\BigNum.cc	/^        friend bool operator<=(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator =	.\BigNum.cc	/^        BigNum& operator=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
BigNum::operator =	.\BigNum.cc	/^BigNum& BigNum::operator=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
BigNum::operator =	.\baidu.cpp	/^	BigNum &operator=(const BigNum &);   \/\/重载赋值运算符，大数之间进行赋值运算$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &)
BigNum::operator =	.\baidu.cpp	/^BigNum & BigNum::operator=(const BigNum & n)   \/\/重载赋值运算符，大数之间进行赋值运算$/;"	f	class:BigNum	signature:(const BigNum & n)
BigNum::operator ==	.\BigNum.cc	/^        friend bool operator==(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator >	.\BigNum.cc	/^        friend bool operator>(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator >	.\baidu.cpp	/^	bool   operator>(const BigNum & T)const;   \/\/大数和另一个大数的大小比较$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum & T) const
BigNum::operator >	.\baidu.cpp	/^	bool   operator>(const int & t)const;      \/\/大数和一个int类型的变量的大小比较$/;"	p	class:BigNum	file:	access:public	signature:(const int & t) const
BigNum::operator >	.\baidu.cpp	/^bool BigNum::operator >(const int & t) const    \/\/大数和一个int类型的变量的大小比较$/;"	f	class:BigNum	signature:(const int & t) const
BigNum::operator >	.\baidu.cpp	/^bool BigNum::operator>(const BigNum & T) const   \/\/大数和另一个大数的大小比较$/;"	f	class:BigNum	signature:(const BigNum & T) const
BigNum::operator >=	.\BigNum.cc	/^        friend bool operator>=(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
BigNum::operator >>	.\baidu.cpp	/^	friend istream& operator>>(istream&,  BigNum&);   \/\/重载输入运算符$/;"	p	class:BigNum	file:	access:friend	signature:(istream&, BigNum&)
BigNum::operator ^	.\baidu.cpp	/^	BigNum operator^(const int  &) const;    \/\/大数的n次方运算$/;"	p	class:BigNum	file:	access:public	signature:(const int &) const
BigNum::operator ^	.\baidu.cpp	/^BigNum BigNum::operator^(const int & n) const    \/\/大数的n次方运算$/;"	f	class:BigNum	signature:(const int & n) const
BigNum::print	.\baidu.cpp	/^	void print();       \/\/输出大数$/;"	p	class:BigNum	file:	access:public	signature:()
BigNum::print	.\baidu.cpp	/^void BigNum::print()    \/\/输出大数$/;"	f	class:BigNum	signature:()
BigNum::sign	.\BigNum.cc	/^        int sign;$/;"	m	class:BigNum	file:	access:private
BorgType	.\catch.hpp	/^        template<typename T> BorgType( T const& );$/;"	p	struct:Catch::Detail::BorgType	access:public	signature:( T const& )
BorgType	.\catch.hpp	/^    struct BorgType {$/;"	s	namespace:Catch::Detail
CATCH_AND_THEN	.\catch.hpp	10407;"	d
CATCH_AND_WHEN	.\catch.hpp	10405;"	d
CATCH_ANON_TEST_CASE	.\catch.hpp	10388;"	d
CATCH_ARC_ENABLED	.\catch.hpp	1507;"	d
CATCH_ARC_STRONG	.\catch.hpp	1525;"	d
CATCH_ARC_STRONG	.\catch.hpp	1541;"	d
CATCH_AUTO_PTR	.\catch.hpp	305;"	d
CATCH_AUTO_PTR	.\catch.hpp	307;"	d
CATCH_BREAK_INTO_DEBUGGER	.\catch.hpp	2014;"	d
CATCH_BREAK_INTO_DEBUGGER	.\catch.hpp	2032;"	d
CATCH_CAPTURE	.\catch.hpp	10368;"	d
CATCH_CHECK	.\catch.hpp	10351;"	d
CATCH_CHECKED_ELSE	.\catch.hpp	10354;"	d
CATCH_CHECKED_IF	.\catch.hpp	10353;"	d
CATCH_CHECK_FALSE	.\catch.hpp	10352;"	d
CATCH_CHECK_NOFAIL	.\catch.hpp	10355;"	d
CATCH_CHECK_NOTHROW	.\catch.hpp	10360;"	d
CATCH_CHECK_THROWS	.\catch.hpp	10357;"	d
CATCH_CHECK_THROWS_AS	.\catch.hpp	10358;"	d
CATCH_CHECK_THROWS_WITH	.\catch.hpp	10359;"	d
CATCH_CONFIG_COLOUR_WINDOWS	.\catch.hpp	7017;"	d
CATCH_CONFIG_CONSOLE_WIDTH	.\catch.hpp	3471;"	d
CATCH_CONFIG_COUNTER	.\catch.hpp	273;"	d
CATCH_CONFIG_CPP11_GENERATED_METHODS	.\catch.hpp	252;"	d
CATCH_CONFIG_CPP11_IS_ENUM	.\catch.hpp	255;"	d
CATCH_CONFIG_CPP11_LONG_LONG	.\catch.hpp	264;"	d
CATCH_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	249;"	d
CATCH_CONFIG_CPP11_NULLPTR	.\catch.hpp	246;"	d
CATCH_CONFIG_CPP11_OVERRIDE	.\catch.hpp	267;"	d
CATCH_CONFIG_CPP11_TUPLE	.\catch.hpp	258;"	d
CATCH_CONFIG_CPP11_UNIQUE_PTR	.\catch.hpp	270;"	d
CATCH_CONFIG_VARIADIC_MACROS	.\catch.hpp	261;"	d
CATCH_CPP11_OR_GREATER	.\catch.hpp	110;"	d
CATCH_FAIL	.\catch.hpp	10377;"	d
CATCH_GENERATE	.\catch.hpp	10393;"	d
CATCH_GIVEN	.\catch.hpp	10403;"	d
CATCH_IMPL	.\catch.hpp	47;"	d
CATCH_INFO	.\catch.hpp	10365;"	d
CATCH_INTERNAL_CONFIG_COUNTER	.\catch.hpp	197;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	.\catch.hpp	175;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	.\catch.hpp	216;"	d
CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM	.\catch.hpp	220;"	d
CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG	.\catch.hpp	232;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	120;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	174;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	212;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	116;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	152;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	169;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	208;"	d
CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE	.\catch.hpp	236;"	d
CATCH_INTERNAL_CONFIG_CPP11_TUPLE	.\catch.hpp	224;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	.\catch.hpp	170;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	.\catch.hpp	239;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	.\catch.hpp	188;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	.\catch.hpp	228;"	d
CATCH_INTERNAL_ERROR	.\catch.hpp	424;"	d
CATCH_INTERNAL_LINEINFO	.\catch.hpp	423;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	.\catch.hpp	124;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	.\catch.hpp	156;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	.\catch.hpp	277;"	d
CATCH_METHOD_AS_TEST_CASE	.\catch.hpp	10374;"	d
CATCH_NOEXCEPT	.\catch.hpp	/^        virtual const char* what() const CATCH_NOEXCEPT;$/;"	m	class:Catch::NotImplementedException	access:public
CATCH_NOEXCEPT	.\catch.hpp	282;"	d
CATCH_NOEXCEPT	.\catch.hpp	285;"	d
CATCH_NOEXCEPT_IS	.\catch.hpp	283;"	d
CATCH_NOEXCEPT_IS	.\catch.hpp	286;"	d
CATCH_NOT_IMPLEMENTED	.\catch.hpp	448;"	d
CATCH_NULL	.\catch.hpp	291;"	d
CATCH_NULL	.\catch.hpp	293;"	d
CATCH_OVERRIDE	.\catch.hpp	298;"	d
CATCH_OVERRIDE	.\catch.hpp	300;"	d
CATCH_PLATFORM_MAC	.\catch.hpp	1993;"	d
CATCH_REGISTER_LEGACY_REPORTER	.\catch.hpp	10391;"	d
CATCH_REGISTER_REPORTER	.\catch.hpp	10390;"	d
CATCH_REGISTER_TAG_ALIAS	.\catch.hpp	2716;"	d
CATCH_REGISTER_TEST_CASE	.\catch.hpp	10375;"	d
CATCH_REQUIRE	.\catch.hpp	10343;"	d
CATCH_REQUIRE_FALSE	.\catch.hpp	10344;"	d
CATCH_REQUIRE_NOTHROW	.\catch.hpp	10349;"	d
CATCH_REQUIRE_THAT	.\catch.hpp	10363;"	d
CATCH_REQUIRE_THROWS	.\catch.hpp	10346;"	d
CATCH_REQUIRE_THROWS_AS	.\catch.hpp	10347;"	d
CATCH_REQUIRE_THROWS_WITH	.\catch.hpp	10348;"	d
CATCH_SCENARIO	.\catch.hpp	10397;"	d
CATCH_SCENARIO_METHOD	.\catch.hpp	10398;"	d
CATCH_SCOPED_CAPTURE	.\catch.hpp	10369;"	d
CATCH_SCOPED_INFO	.\catch.hpp	10367;"	d
CATCH_SECTION	.\catch.hpp	10376;"	d
CATCH_SUCCEED	.\catch.hpp	10378;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	.\catch.hpp	3612;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	.\catch.hpp	4638;"	d
CATCH_TEST_CASE	.\catch.hpp	10372;"	d
CATCH_TEST_CASE_METHOD	.\catch.hpp	10373;"	d
CATCH_THEN	.\catch.hpp	10406;"	d
CATCH_TRANSLATE_EXCEPTION	.\catch.hpp	10466;"	d
CATCH_UNSAFE_UNRETAINED	.\catch.hpp	1524;"	d
CATCH_UNSAFE_UNRETAINED	.\catch.hpp	1540;"	d
CATCH_WARN	.\catch.hpp	10366;"	d
CATCH_WHEN	.\catch.hpp	10404;"	d
CHECK_THAT	.\catch.hpp	10362;"	d
CLARA_AUTO_PTR	.\catch.hpp	3923;"	d
CLARA_CONFIG_CONSOLE_WIDTH	.\catch.hpp	3613;"	d
CLARA_CONFIG_CONSOLE_WIDTH	.\catch.hpp	3615;"	d
CLARA_CONFIG_CONSOLE_WIDTH	.\catch.hpp	4637;"	d
CLARA_CONFIG_CPP11_GENERATED_METHODS	.\catch.hpp	3889;"	d
CLARA_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	3886;"	d
CLARA_CONFIG_CPP11_NULLPTR	.\catch.hpp	3883;"	d
CLARA_CONFIG_CPP11_OVERRIDE	.\catch.hpp	3892;"	d
CLARA_CONFIG_CPP11_UNIQUE_PTR	.\catch.hpp	3895;"	d
CLARA_CONFIG_MAIN	.\catch.hpp	10335;"	d
CLARA_CONFIG_MAIN	.\catch.hpp	53;"	d
CLARA_CONFIG_MAIN_NOT_DEFINED	.\catch.hpp	52;"	d
CLARA_CPP11_OR_GREATER	.\catch.hpp	3858;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	.\catch.hpp	3847;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	.\catch.hpp	3869;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	3818;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	3846;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	.\catch.hpp	3865;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	3814;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	3828;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	3841;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	.\catch.hpp	3861;"	d
CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE	.\catch.hpp	3873;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	.\catch.hpp	3842;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	.\catch.hpp	3876;"	d
CLARA_NOEXCEPT	.\catch.hpp	3900;"	d
CLARA_NOEXCEPT_IS	.\catch.hpp	3901;"	d
CLARA_NULL	.\catch.hpp	3909;"	d
CLARA_OVERRIDE	.\catch.hpp	3916;"	d
CLARA_PLATFORM_WINDOWS	.\catch.hpp	3938;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	.\catch.hpp	4840;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	.\catch.hpp	4988;"	d
CaseSensitive	.\catch.hpp	/^    struct CaseSensitive { enum Choice {$/;"	s	namespace:Catch
CasedString	.\catch.hpp	/^            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	access:public	signature:( std::string const& str, CaseSensitive::Choice caseSensitivity )
CasedString	.\catch.hpp	/^        struct CasedString$/;"	s	namespace:Catch::Matchers::Impl::StdString
Catch	.\catch.hpp	/^namespace Catch {$/;"	n
Catch::AssertionInfo	.\catch.hpp	/^    struct AssertionInfo$/;"	s	namespace:Catch
Catch::AssertionInfo::AssertionInfo	.\catch.hpp	/^        AssertionInfo(  std::string const& _macroName,$/;"	p	struct:Catch::AssertionInfo	access:public	signature:( std::string const& _macroName, SourceLineInfo const& _lineInfo, std::string const& _capturedExpression, ResultDisposition::Flags _resultDisposition )
Catch::AssertionInfo::AssertionInfo	.\catch.hpp	/^        AssertionInfo() {}$/;"	f	struct:Catch::AssertionInfo	access:public	signature:()
Catch::AssertionInfo::capturedExpression	.\catch.hpp	/^        std::string capturedExpression;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionInfo::lineInfo	.\catch.hpp	/^        SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionInfo::macroName	.\catch.hpp	/^        std::string macroName;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionInfo::resultDisposition	.\catch.hpp	/^        ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionResult	.\catch.hpp	/^    class AssertionResult {$/;"	c	namespace:Catch
Catch::AssertionResult::AssertionResult	.\catch.hpp	/^         AssertionResult( AssertionResult && )                  = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
Catch::AssertionResult::AssertionResult	.\catch.hpp	/^         AssertionResult( AssertionResult const& )              = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
Catch::AssertionResult::AssertionResult	.\catch.hpp	/^        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionInfo const& info, AssertionResultData const& data )
Catch::AssertionResult::AssertionResult	.\catch.hpp	/^        AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
Catch::AssertionResult::getExpandedExpression	.\catch.hpp	/^        std::string getExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getExpression	.\catch.hpp	/^        std::string getExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getExpressionInMacro	.\catch.hpp	/^        std::string getExpressionInMacro() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getMessage	.\catch.hpp	/^        std::string getMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getResultType	.\catch.hpp	/^        ResultWas::OfType getResultType() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getSourceInfo	.\catch.hpp	/^        SourceLineInfo getSourceInfo() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getTestMacroName	.\catch.hpp	/^        std::string getTestMacroName() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::hasExpandedExpression	.\catch.hpp	/^        bool hasExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::hasExpression	.\catch.hpp	/^        bool hasExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::hasMessage	.\catch.hpp	/^        bool hasMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::isOk	.\catch.hpp	/^        bool isOk() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::m_info	.\catch.hpp	/^        AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult	access:protected
Catch::AssertionResult::m_resultData	.\catch.hpp	/^        AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult	access:protected
Catch::AssertionResult::operator =	.\catch.hpp	/^         AssertionResult& operator = ( AssertionResult && )     = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
Catch::AssertionResult::operator =	.\catch.hpp	/^         AssertionResult& operator = ( AssertionResult const& ) = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
Catch::AssertionResult::succeeded	.\catch.hpp	/^        bool succeeded() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::~AssertionResult	.\catch.hpp	/^        ~AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
Catch::AssertionResultData	.\catch.hpp	/^    struct AssertionResultData$/;"	s	namespace:Catch
Catch::AssertionResultData::AssertionResultData	.\catch.hpp	/^        AssertionResultData() : resultType( ResultWas::Unknown ) {}$/;"	f	struct:Catch::AssertionResultData	access:public	signature:()
Catch::AssertionResultData::message	.\catch.hpp	/^        std::string message;$/;"	m	struct:Catch::AssertionResultData	access:public
Catch::AssertionResultData::reconstructedExpression	.\catch.hpp	/^        std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData	access:public
Catch::AssertionResultData::resultType	.\catch.hpp	/^        ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData	access:public
Catch::AutoReg	.\catch.hpp	/^struct AutoReg {$/;"	s	namespace:Catch
Catch::AutoReg::AutoReg	.\catch.hpp	/^    AutoReg$/;"	f	struct:Catch::AutoReg	access:public	signature:( void (C::*method)(), char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
Catch::AutoReg::AutoReg	.\catch.hpp	/^    AutoReg$/;"	p	struct:Catch::AutoReg	access:public	signature:( TestFunction function, SourceLineInfo const& lineInfo, NameAndDesc const& nameAndDesc )
Catch::AutoReg::AutoReg	.\catch.hpp	/^    AutoReg( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
Catch::AutoReg::operator =	.\catch.hpp	/^    void operator= ( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
Catch::AutoReg::~AutoReg	.\catch.hpp	/^    ~AutoReg();$/;"	p	struct:Catch::AutoReg	access:public	signature:()
Catch::CaseSensitive	.\catch.hpp	/^    struct CaseSensitive { enum Choice {$/;"	s	namespace:Catch
Catch::CaseSensitive::Choice	.\catch.hpp	/^    struct CaseSensitive { enum Choice {$/;"	g	struct:Catch::CaseSensitive	access:public
Catch::CaseSensitive::No	.\catch.hpp	/^        No$/;"	e	enum:Catch::CaseSensitive::Choice
Catch::CaseSensitive::Yes	.\catch.hpp	/^        Yes,$/;"	e	enum:Catch::CaseSensitive::Choice
Catch::CopyableStream	.\catch.hpp	/^    struct CopyableStream {$/;"	s	namespace:Catch
Catch::CopyableStream::CopyableStream	.\catch.hpp	/^        CopyableStream( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
Catch::CopyableStream::CopyableStream	.\catch.hpp	/^        CopyableStream() {}$/;"	f	struct:Catch::CopyableStream	access:public	signature:()
Catch::CopyableStream::operator =	.\catch.hpp	/^        CopyableStream& operator=( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
Catch::CopyableStream::oss	.\catch.hpp	/^        std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream	access:public
Catch::Detail	.\catch.hpp	/^namespace Detail {$/;"	n	namespace:Catch
Catch::Detail::BorgType	.\catch.hpp	/^    struct BorgType {$/;"	s	namespace:Catch::Detail
Catch::Detail::BorgType::BorgType	.\catch.hpp	/^        template<typename T> BorgType( T const& );$/;"	p	struct:Catch::Detail::BorgType	access:public	signature:( T const& )
Catch::Detail::EnumStringMaker	.\catch.hpp	/^    struct EnumStringMaker$/;"	s	namespace:Catch::Detail
Catch::Detail::EnumStringMaker	.\catch.hpp	/^    struct EnumStringMaker<T,true>$/;"	s	namespace:Catch::Detail
Catch::Detail::EnumStringMaker::convert	.\catch.hpp	/^        static std::string convert( T const& ) { return unprintableString; }$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& )
Catch::Detail::EnumStringMaker::convert	.\catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& v )
Catch::Detail::FalseType	.\catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	s	namespace:Catch::Detail
Catch::Detail::FalseType::sizer	.\catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	m	struct:Catch::Detail::FalseType	access:public
Catch::Detail::IsStreamInsertable	.\catch.hpp	/^    struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
Catch::Detail::IsStreamInsertable::s	.\catch.hpp	/^        static std::ostream &s;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
Catch::Detail::IsStreamInsertable::t	.\catch.hpp	/^        static T  const&t;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
Catch::Detail::IsStreamInsertable::value	.\catch.hpp	/^        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon1
Catch::Detail::StringMakerBase	.\catch.hpp	/^    struct StringMakerBase {$/;"	s	namespace:Catch::Detail
Catch::Detail::StringMakerBase	.\catch.hpp	/^    struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
Catch::Detail::StringMakerBase::convert	.\catch.hpp	/^        static std::string convert( T const& _value ) {$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& _value )
Catch::Detail::StringMakerBase::convert	.\catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& v )
Catch::Detail::TrueType	.\catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	s	namespace:Catch::Detail
Catch::Detail::TrueType::sizer	.\catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	m	struct:Catch::Detail::TrueType	access:public
Catch::Detail::operator <<	.\catch.hpp	/^    FalseType operator<<( std::ostream const&, BorgType const& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream const&, BorgType const& )
Catch::Detail::rangeToString	.\catch.hpp	/^    std::string rangeToString( InputIterator first, InputIterator last );$/;"	p	namespace:Catch::Detail	signature:( InputIterator first, InputIterator last )
Catch::Detail::rawMemoryToString	.\catch.hpp	/^    inline std::string rawMemoryToString( const T& object ) {$/;"	f	namespace:Catch::Detail	signature:( const T& object )
Catch::Detail::rawMemoryToString	.\catch.hpp	/^    std::string rawMemoryToString( const void *object, std::size_t size );$/;"	p	namespace:Catch::Detail	signature:( const void *object, std::size_t size )
Catch::Detail::testStreamable	.\catch.hpp	/^    FalseType testStreamable( FalseType );$/;"	p	namespace:Catch::Detail	signature:( FalseType )
Catch::Detail::testStreamable	.\catch.hpp	/^    TrueType& testStreamable( std::ostream& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream& )
Catch::IContext	.\catch.hpp	/^    struct IContext$/;"	s	namespace:Catch
Catch::IContext::advanceGeneratorsForCurrentTest	.\catch.hpp	/^        virtual bool advanceGeneratorsForCurrentTest() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IContext::getConfig	.\catch.hpp	/^        virtual Ptr<IConfig const> getConfig() const = 0;$/;"	p	struct:Catch::IContext	access:public	signature:() const
Catch::IContext::getGeneratorIndex	.\catch.hpp	/^        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;$/;"	p	struct:Catch::IContext	access:public	signature:( std::string const& fileInfo, size_t totalSize )
Catch::IContext::getResultCapture	.\catch.hpp	/^        virtual IResultCapture* getResultCapture() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IContext::getRunner	.\catch.hpp	/^        virtual IRunner* getRunner() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IContext::~IContext	.\catch.hpp	/^        virtual ~IContext();$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IGeneratorInfo	.\catch.hpp	/^    struct IGeneratorInfo {$/;"	s	namespace:Catch
Catch::IGeneratorInfo::getCurrentIndex	.\catch.hpp	/^        virtual std::size_t getCurrentIndex() const = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:() const
Catch::IGeneratorInfo::moveNext	.\catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
Catch::IGeneratorInfo::~IGeneratorInfo	.\catch.hpp	/^        virtual ~IGeneratorInfo();$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
Catch::IGeneratorsForTest	.\catch.hpp	/^    struct IGeneratorsForTest {$/;"	s	namespace:Catch
Catch::IGeneratorsForTest::getGeneratorInfo	.\catch.hpp	/^        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:( std::string const& fileInfo, std::size_t size )
Catch::IGeneratorsForTest::moveNext	.\catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
Catch::IGeneratorsForTest::~IGeneratorsForTest	.\catch.hpp	/^        virtual ~IGeneratorsForTest();$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
Catch::IMutableContext	.\catch.hpp	/^    struct IMutableContext : IContext$/;"	s	namespace:Catch	inherits:IContext
Catch::IMutableContext::setConfig	.\catch.hpp	/^        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( Ptr<IConfig const> const& config )
Catch::IMutableContext::setResultCapture	.\catch.hpp	/^        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IResultCapture* resultCapture )
Catch::IMutableContext::setRunner	.\catch.hpp	/^        virtual void setRunner( IRunner* runner ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IRunner* runner )
Catch::IMutableContext::~IMutableContext	.\catch.hpp	/^        virtual ~IMutableContext();$/;"	p	struct:Catch::IMutableContext	access:public	signature:()
Catch::IShared	.\catch.hpp	/^    struct IShared : NonCopyable {$/;"	s	namespace:Catch	inherits:NonCopyable
Catch::IShared::addRef	.\catch.hpp	/^        virtual void addRef() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
Catch::IShared::release	.\catch.hpp	/^        virtual void release() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
Catch::IShared::~IShared	.\catch.hpp	/^        virtual ~IShared();$/;"	p	struct:Catch::IShared	access:public	signature:()
Catch::ITestCase	.\catch.hpp	/^    struct ITestCase : IShared {$/;"	s	namespace:Catch	inherits:IShared
Catch::ITestCase::invoke	.\catch.hpp	/^        virtual void invoke () const = 0;$/;"	p	struct:Catch::ITestCase	access:public	signature:() const
Catch::ITestCase::~ITestCase	.\catch.hpp	/^        virtual ~ITestCase();$/;"	p	struct:Catch::ITestCase	access:protected	signature:()
Catch::ITestCaseRegistry	.\catch.hpp	/^    struct ITestCaseRegistry {$/;"	s	namespace:Catch
Catch::ITestCaseRegistry::std::getAllTests	.\catch.hpp	/^        virtual std::vector<TestCase> const& getAllTests() const = 0;$/;"	p	class:Catch::ITestCaseRegistry::std	access:public	signature:() const
Catch::ITestCaseRegistry::std::getAllTestsSorted	.\catch.hpp	/^        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;$/;"	p	class:Catch::ITestCaseRegistry::std	access:public	signature:( IConfig const& config ) const
Catch::ITestCaseRegistry::~ITestCaseRegistry	.\catch.hpp	/^        virtual ~ITestCaseRegistry();$/;"	p	struct:Catch::ITestCaseRegistry	access:public	signature:()
Catch::Internal	.\catch.hpp	/^namespace Internal {$/;"	n	namespace:Catch
Catch::Internal::Evaluator	.\catch.hpp	/^    class Evaluator{};$/;"	c	namespace:Catch::Internal
Catch::Internal::Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator::evaluate	.\catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs ) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs )
Catch::Internal::Evaluator::evaluate	.\catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs)
Catch::Internal::IsEqualTo	.\catch.hpp	/^        IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsGreaterThan	.\catch.hpp	/^        IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsGreaterThanOrEqualTo	.\catch.hpp	/^        IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsLessThan	.\catch.hpp	/^        IsLessThan,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsLessThanOrEqualTo	.\catch.hpp	/^        IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsNotEqualTo	.\catch.hpp	/^        IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::Operator	.\catch.hpp	/^    enum Operator {$/;"	g	namespace:Catch::Internal
Catch::Internal::OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	.\catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits::getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	.\catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::applyEvaluator	.\catch.hpp	/^    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
Catch::Internal::compare	.\catch.hpp	/^    bool compare( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, long long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, std::nullptr_t )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, T* rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, T* rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, T* rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( std::nullptr_t, T* rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned char rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned char rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned char rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned long long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, char rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, int rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, long long rhs )
Catch::Internal::compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, long rhs )
Catch::Internal::opCast	.\catch.hpp	/^    inline T& opCast(T const& t) { return const_cast<T&>(t); }$/;"	f	namespace:Catch::Internal	signature:(T const& t)
Catch::Internal::opCast	.\catch.hpp	/^    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }$/;"	f	namespace:Catch::Internal	signature:(std::nullptr_t)
Catch::Matchers	.\catch.hpp	/^namespace Matchers {$/;"	n	namespace:Catch
Catch::Matchers::AllOf	.\catch.hpp	/^    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2 )
Catch::Matchers::AllOf	.\catch.hpp	/^    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2, Impl::Matcher<ExpressionT> const& m3 )
Catch::Matchers::AnyOf	.\catch.hpp	/^    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2 )
Catch::Matchers::AnyOf	.\catch.hpp	/^    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m1, Impl::Matcher<ExpressionT> const& m2, Impl::Matcher<ExpressionT> const& m3 )
Catch::Matchers::Contains	.\catch.hpp	/^    inline Impl::StdString::Contains    Contains( const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::Contains	.\catch.hpp	/^    inline Impl::StdString::Contains    Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::EndsWith	.\catch.hpp	/^    inline Impl::StdString::EndsWith    EndsWith( const char* substr ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* substr )
Catch::Matchers::EndsWith	.\catch.hpp	/^    inline Impl::StdString::EndsWith    EndsWith( std::string const& substr ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& substr )
Catch::Matchers::Equals	.\catch.hpp	/^    inline Impl::StdString::Equals      Equals( const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::Equals	.\catch.hpp	/^    inline Impl::StdString::Equals      Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::Impl	.\catch.hpp	/^    namespace Impl {$/;"	n	namespace:Catch::Matchers
Catch::Matchers::Impl::Generic	.\catch.hpp	/^    namespace Generic {$/;"	n	namespace:Catch::Matchers::Impl
Catch::Matchers::Impl::Generic::AllOf	.\catch.hpp	/^        class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic	inherits:MatcherImpl
Catch::Matchers::Impl::Generic::AllOf::AllOf	.\catch.hpp	/^            AllOf( AllOf const& other ) : m_matchers( other.m_matchers ) {}$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( AllOf const& other )
Catch::Matchers::Impl::Generic::AllOf::AllOf	.\catch.hpp	/^            AllOf() {}$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:()
Catch::Matchers::Impl::Generic::AllOf::add	.\catch.hpp	/^            AllOf& add( Matcher<ExpressionT> const& matcher ) {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( Matcher<ExpressionT> const& matcher )
Catch::Matchers::Impl::Generic::AllOf::m_matchers	.\catch.hpp	/^            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;$/;"	m	class:Catch::Matchers::Impl::Generic::AllOf	access:private
Catch::Matchers::Impl::Generic::AllOf::match	.\catch.hpp	/^            virtual bool match( ExpressionT const& expr ) const$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( ExpressionT const& expr ) const
Catch::Matchers::Impl::Generic::AllOf::operator &&	.\catch.hpp	/^            AllOf operator && ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( Matcher<ExpressionT> const& other ) const
Catch::Matchers::Impl::Generic::AllOf::toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:() const
Catch::Matchers::Impl::Generic::AnyOf	.\catch.hpp	/^        class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic	inherits:MatcherImpl
Catch::Matchers::Impl::Generic::AnyOf::AnyOf	.\catch.hpp	/^            AnyOf( AnyOf const& other ) : m_matchers( other.m_matchers ) {}$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( AnyOf const& other )
Catch::Matchers::Impl::Generic::AnyOf::AnyOf	.\catch.hpp	/^            AnyOf() {}$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:()
Catch::Matchers::Impl::Generic::AnyOf::add	.\catch.hpp	/^            AnyOf& add( Matcher<ExpressionT> const& matcher ) {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( Matcher<ExpressionT> const& matcher )
Catch::Matchers::Impl::Generic::AnyOf::m_matchers	.\catch.hpp	/^            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;$/;"	m	class:Catch::Matchers::Impl::Generic::AnyOf	access:private
Catch::Matchers::Impl::Generic::AnyOf::match	.\catch.hpp	/^            virtual bool match( ExpressionT const& expr ) const$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( ExpressionT const& expr ) const
Catch::Matchers::Impl::Generic::AnyOf::operator ||	.\catch.hpp	/^            AnyOf operator || ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( Matcher<ExpressionT> const& other ) const
Catch::Matchers::Impl::Generic::AnyOf::toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:() const
Catch::Matchers::Impl::Generic::Not	.\catch.hpp	/^        class Not : public MatcherImpl<Not<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic	inherits:MatcherImpl
Catch::Matchers::Impl::Generic::Not::Not	.\catch.hpp	/^            Not( Not const& other ) : m_matcher( other.m_matcher ) {}$/;"	f	class:Catch::Matchers::Impl::Generic::Not	access:public	signature:( Not const& other )
Catch::Matchers::Impl::Generic::Not::Not	.\catch.hpp	/^            explicit Not( Matcher<ExpressionT> const& matcher ) : m_matcher(matcher.clone()) {}$/;"	f	class:Catch::Matchers::Impl::Generic::Not	access:public	signature:( Matcher<ExpressionT> const& matcher )
Catch::Matchers::Impl::Generic::Not::m_matcher	.\catch.hpp	/^            Ptr< Matcher<ExpressionT> > m_matcher;$/;"	m	class:Catch::Matchers::Impl::Generic::Not	access:private
Catch::Matchers::Impl::Matcher	.\catch.hpp	/^    struct Matcher : SharedImpl<IShared>$/;"	s	namespace:Catch::Matchers::Impl	inherits:SharedImpl
Catch::Matchers::Impl::Matcher::ExpressionType	.\catch.hpp	/^        typedef ExpressionT ExpressionType;$/;"	t	struct:Catch::Matchers::Impl::Matcher	access:public
Catch::Matchers::Impl::Matcher::clone	.\catch.hpp	/^        virtual Ptr<Matcher> clone() const = 0;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:() const
Catch::Matchers::Impl::Matcher::match	.\catch.hpp	/^        virtual bool match( ExpressionT const& expr ) const = 0;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:( ExpressionT const& expr ) const
Catch::Matchers::Impl::Matcher::operator !	.\catch.hpp	/^        Generic::Not<ExpressionT> operator ! () const;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:() const
Catch::Matchers::Impl::Matcher::operator !	.\catch.hpp	/^    Generic::Not<ExpressionT> Matcher<ExpressionT>::operator ! () const {$/;"	f	class:Catch::Matchers::Impl::Matcher	signature:() const
Catch::Matchers::Impl::Matcher::operator &&	.\catch.hpp	/^        Generic::AllOf<ExpressionT> operator && ( Matcher<ExpressionT> const& other ) const;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:( Matcher<ExpressionT> const& other ) const
Catch::Matchers::Impl::Matcher::operator &&	.\catch.hpp	/^    Generic::AllOf<ExpressionT> Matcher<ExpressionT>::operator && ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Matcher	signature:( Matcher<ExpressionT> const& other ) const
Catch::Matchers::Impl::Matcher::operator ||	.\catch.hpp	/^        Generic::AnyOf<ExpressionT> operator || ( Matcher<ExpressionT> const& other ) const;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:( Matcher<ExpressionT> const& other ) const
Catch::Matchers::Impl::Matcher::operator ||	.\catch.hpp	/^    Generic::AnyOf<ExpressionT> Matcher<ExpressionT>::operator || ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Matcher	signature:( Matcher<ExpressionT> const& other ) const
Catch::Matchers::Impl::Matcher::toString	.\catch.hpp	/^        virtual std::string toString() const = 0;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:() const
Catch::Matchers::Impl::Matcher::~Matcher	.\catch.hpp	/^        virtual ~Matcher() {}$/;"	f	struct:Catch::Matchers::Impl::Matcher	access:public	signature:()
Catch::Matchers::Impl::MatcherImpl	.\catch.hpp	/^    struct MatcherImpl : Matcher<ExpressionT> {$/;"	s	namespace:Catch::Matchers::Impl	inherits:Matcher
Catch::Matchers::Impl::MatcherImpl::clone	.\catch.hpp	/^        virtual Ptr<Matcher<ExpressionT> > clone() const {$/;"	f	struct:Catch::Matchers::Impl::MatcherImpl	access:public	signature:() const
Catch::Matchers::Impl::StdString	.\catch.hpp	/^    namespace StdString {$/;"	n	namespace:Catch::Matchers::Impl
Catch::Matchers::Impl::StdString::CasedString	.\catch.hpp	/^        struct CasedString$/;"	s	namespace:Catch::Matchers::Impl::StdString
Catch::Matchers::Impl::StdString::CasedString::CasedString	.\catch.hpp	/^            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	access:public	signature:( std::string const& str, CaseSensitive::Choice caseSensitivity )
Catch::Matchers::Impl::StdString::CasedString::adjustString	.\catch.hpp	/^            std::string adjustString( std::string const& str ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	access:public	signature:( std::string const& str ) const
Catch::Matchers::Impl::StdString::CasedString::m_caseSensitivity	.\catch.hpp	/^            CaseSensitive::Choice m_caseSensitivity;$/;"	m	struct:Catch::Matchers::Impl::StdString::CasedString	access:public
Catch::Matchers::Impl::StdString::CasedString::m_str	.\catch.hpp	/^            std::string m_str;$/;"	m	struct:Catch::Matchers::Impl::StdString::CasedString	access:public
Catch::Matchers::Impl::StdString::CasedString::toStringSuffix	.\catch.hpp	/^            std::string toStringSuffix() const$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	access:public	signature:() const
Catch::Matchers::Impl::StdString::Contains	.\catch.hpp	/^        struct Contains : MatcherImpl<Contains, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
Catch::Matchers::Impl::StdString::Contains::Contains	.\catch.hpp	/^            Contains( Contains const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:( Contains const& other )
Catch::Matchers::Impl::StdString::Contains::Contains	.\catch.hpp	/^            Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::Impl::StdString::Contains::m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::Contains	access:public
Catch::Matchers::Impl::StdString::Contains::match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:( std::string const& expr ) const
Catch::Matchers::Impl::StdString::Contains::toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:() const
Catch::Matchers::Impl::StdString::Contains::~Contains	.\catch.hpp	/^            virtual ~Contains();$/;"	p	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:()
Catch::Matchers::Impl::StdString::EndsWith	.\catch.hpp	/^        struct EndsWith : MatcherImpl<EndsWith, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
Catch::Matchers::Impl::StdString::EndsWith::EndsWith	.\catch.hpp	/^            EndsWith( EndsWith const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:( EndsWith const& other )
Catch::Matchers::Impl::StdString::EndsWith::EndsWith	.\catch.hpp	/^            EndsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::Impl::StdString::EndsWith::m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public
Catch::Matchers::Impl::StdString::EndsWith::match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:( std::string const& expr ) const
Catch::Matchers::Impl::StdString::EndsWith::toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:() const
Catch::Matchers::Impl::StdString::EndsWith::~EndsWith	.\catch.hpp	/^            virtual ~EndsWith();$/;"	p	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:()
Catch::Matchers::Impl::StdString::Equals	.\catch.hpp	/^        struct Equals : MatcherImpl<Equals, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
Catch::Matchers::Impl::StdString::Equals::Equals	.\catch.hpp	/^            Equals( Equals const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:( Equals const& other )
Catch::Matchers::Impl::StdString::Equals::Equals	.\catch.hpp	/^            Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::Impl::StdString::Equals::m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::Equals	access:public
Catch::Matchers::Impl::StdString::Equals::match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:( std::string const& expr ) const
Catch::Matchers::Impl::StdString::Equals::toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:() const
Catch::Matchers::Impl::StdString::Equals::~Equals	.\catch.hpp	/^            virtual ~Equals();$/;"	p	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:()
Catch::Matchers::Impl::StdString::StartsWith	.\catch.hpp	/^        struct StartsWith : MatcherImpl<StartsWith, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
Catch::Matchers::Impl::StdString::StartsWith::StartsWith	.\catch.hpp	/^            StartsWith( StartsWith const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:( StartsWith const& other )
Catch::Matchers::Impl::StdString::StartsWith::StartsWith	.\catch.hpp	/^            StartsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Catch::Matchers::Impl::StdString::StartsWith::m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public
Catch::Matchers::Impl::StdString::StartsWith::match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:( std::string const& expr ) const
Catch::Matchers::Impl::StdString::StartsWith::toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:() const
Catch::Matchers::Impl::StdString::StartsWith::~StartsWith	.\catch.hpp	/^            virtual ~StartsWith();$/;"	p	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:()
Catch::Matchers::Impl::StdString::makeString	.\catch.hpp	/^        inline std::string makeString( const char* str ) { return str ? std::string( str ) : std::string(); }$/;"	f	namespace:Catch::Matchers::Impl::StdString	signature:( const char* str )
Catch::Matchers::Impl::StdString::makeString	.\catch.hpp	/^        inline std::string makeString( std::string const& str ) { return str; }$/;"	f	namespace:Catch::Matchers::Impl::StdString	signature:( std::string const& str )
Catch::Matchers::Not	.\catch.hpp	/^    inline Impl::Generic::Not<ExpressionT> Not( Impl::Matcher<ExpressionT> const& m ) {$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m )
Catch::Matchers::StartsWith	.\catch.hpp	/^    inline Impl::StdString::StartsWith  StartsWith( const char* substr ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* substr )
Catch::Matchers::StartsWith	.\catch.hpp	/^    inline Impl::StdString::StartsWith  StartsWith( std::string const& substr ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& substr )
Catch::MethodTestCase	.\catch.hpp	/^class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch	inherits:SharedImpl
Catch::MethodTestCase::MethodTestCase	.\catch.hpp	/^    MethodTestCase( void (C::*method)() ) : m_method( method ) {}$/;"	f	class:Catch::MethodTestCase	access:public	signature:( void (C::*method)() )
Catch::MethodTestCase::invoke	.\catch.hpp	/^    virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase	access:public	signature:() const
Catch::MethodTestCase::m_method	.\catch.hpp	/^    void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase	access:private
Catch::MethodTestCase::~MethodTestCase	.\catch.hpp	/^    virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase	access:private	signature:()
Catch::NameAndDesc	.\catch.hpp	/^struct NameAndDesc {$/;"	s	namespace:Catch
Catch::NameAndDesc::NameAndDesc	.\catch.hpp	/^    NameAndDesc( const char* _name = "", const char* _description= "" )$/;"	f	struct:Catch::NameAndDesc	access:public	signature:( const char* _name = , const char* _description=  )
Catch::NameAndDesc::description	.\catch.hpp	/^    const char* description;$/;"	m	struct:Catch::NameAndDesc	access:public
Catch::NameAndDesc::name	.\catch.hpp	/^    const char* name;$/;"	m	struct:Catch::NameAndDesc	access:public
Catch::NonCopyable	.\catch.hpp	/^    class NonCopyable {$/;"	c	namespace:Catch
Catch::NonCopyable::NonCopyable	.\catch.hpp	/^        NonCopyable( NonCopyable && )                  = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
Catch::NonCopyable::NonCopyable	.\catch.hpp	/^        NonCopyable( NonCopyable const& )              = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
Catch::NonCopyable::NonCopyable	.\catch.hpp	/^        NonCopyable() {}$/;"	f	class:Catch::NonCopyable	access:protected	signature:()
Catch::NonCopyable::operator =	.\catch.hpp	/^        NonCopyable& operator = ( NonCopyable && )     = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
Catch::NonCopyable::operator =	.\catch.hpp	/^        NonCopyable& operator = ( NonCopyable const& ) = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
Catch::NonCopyable::~NonCopyable	.\catch.hpp	/^        virtual ~NonCopyable();$/;"	p	class:Catch::NonCopyable	access:protected	signature:()
Catch::NotImplementedException	.\catch.hpp	/^    class NotImplementedException : public std::exception$/;"	c	namespace:Catch	inherits:std::exception
Catch::NotImplementedException::CATCH_NOEXCEPT	.\catch.hpp	/^        virtual const char* what() const CATCH_NOEXCEPT;$/;"	m	class:Catch::NotImplementedException	access:public
Catch::NotImplementedException::NotImplementedException	.\catch.hpp	/^        NotImplementedException( NotImplementedException const& ) {}$/;"	f	class:Catch::NotImplementedException	access:public	signature:( NotImplementedException const& )
Catch::NotImplementedException::NotImplementedException	.\catch.hpp	/^        NotImplementedException( SourceLineInfo const& lineInfo );$/;"	p	class:Catch::NotImplementedException	access:public	signature:( SourceLineInfo const& lineInfo )
Catch::NotImplementedException::m_lineInfo	.\catch.hpp	/^        SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException	access:private
Catch::NotImplementedException::m_what	.\catch.hpp	/^        std::string m_what;$/;"	m	class:Catch::NotImplementedException	access:private
Catch::Ptr	.\catch.hpp	/^    class Ptr {$/;"	c	namespace:Catch
Catch::Ptr::Ptr	.\catch.hpp	/^        Ptr( Ptr const& other ) : m_p( other.m_p ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
Catch::Ptr::Ptr	.\catch.hpp	/^        Ptr( T* p ) : m_p( p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
Catch::Ptr::Ptr	.\catch.hpp	/^        Ptr() : m_p( CATCH_NULL ){}$/;"	f	class:Catch::Ptr	access:public	signature:()
Catch::Ptr::get	.\catch.hpp	/^        T* get() const{ return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::m_p	.\catch.hpp	/^        T* m_p;$/;"	m	class:Catch::Ptr	access:private
Catch::Ptr::operator !	.\catch.hpp	/^        bool operator !() const { return m_p == CATCH_NULL; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::operator *	.\catch.hpp	/^        T& operator*() const { return *m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::operator ->	.\catch.hpp	/^        T* operator->() const { return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::operator =	.\catch.hpp	/^        Ptr& operator = ( Ptr const& other ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
Catch::Ptr::operator =	.\catch.hpp	/^        Ptr& operator = ( T* p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
Catch::Ptr::operator SafeBool::type	.\catch.hpp	/^        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::reset	.\catch.hpp	/^        void reset() {$/;"	f	class:Catch::Ptr	access:public	signature:()
Catch::Ptr::swap	.\catch.hpp	/^        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr& other )
Catch::Ptr::~Ptr	.\catch.hpp	/^        ~Ptr(){$/;"	f	class:Catch::Ptr	access:public	signature:()
Catch::ResultBuilder	.\catch.hpp	/^    class ResultBuilder {$/;"	c	namespace:Catch
Catch::ResultBuilder::ExprComponents	.\catch.hpp	/^        struct ExprComponents {$/;"	s	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::ExprComponents::ExprComponents	.\catch.hpp	/^            ExprComponents() : testFalse( false ) {}$/;"	f	struct:Catch::ResultBuilder::ExprComponents	access:public	signature:()
Catch::ResultBuilder::ExprComponents::lhs	.\catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ExprComponents::op	.\catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ExprComponents::rhs	.\catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ExprComponents::testFalse	.\catch.hpp	/^            bool testFalse;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ResultBuilder	.\catch.hpp	/^        ResultBuilder(  char const* macroName,$/;"	p	class:Catch::ResultBuilder	access:public	signature:( char const* macroName, SourceLineInfo const& lineInfo, char const* capturedExpression, ResultDisposition::Flags resultDisposition, char const* secondArg =  )
Catch::ResultBuilder::allowThrows	.\catch.hpp	/^        bool allowThrows() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::build	.\catch.hpp	/^        AssertionResult build() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::captureExpectedException	.\catch.hpp	/^        void captureExpectedException( Matchers::Impl::Matcher<std::string> const& matcher );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( Matchers::Impl::Matcher<std::string> const& matcher )
Catch::ResultBuilder::captureExpectedException	.\catch.hpp	/^        void captureExpectedException( std::string const& expectedMessage );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& expectedMessage )
Catch::ResultBuilder::captureExpression	.\catch.hpp	/^        void captureExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
Catch::ResultBuilder::captureResult	.\catch.hpp	/^        void captureResult( ResultWas::OfType resultType );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType resultType )
Catch::ResultBuilder::endExpression	.\catch.hpp	/^        void endExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
Catch::ResultBuilder::handleResult	.\catch.hpp	/^        void handleResult( AssertionResult const& result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( AssertionResult const& result )
Catch::ResultBuilder::m_assertionInfo	.\catch.hpp	/^        AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_data	.\catch.hpp	/^        AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_exprComponents	.\catch.hpp	/^        } m_exprComponents;$/;"	m	class:Catch::ResultBuilder	typeref:struct:Catch::ResultBuilder::ExprComponents	access:private
Catch::ResultBuilder::m_shouldDebugBreak	.\catch.hpp	/^        bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_shouldThrow	.\catch.hpp	/^        bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_stream	.\catch.hpp	/^        CopyableStream m_stream;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::operator &&	.\catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
Catch::ResultBuilder::operator <<	.\catch.hpp	/^        ResultBuilder& operator << ( T const& value ) {$/;"	f	class:Catch::ResultBuilder	access:public	signature:( T const& value )
Catch::ResultBuilder::operator <=	.\catch.hpp	/^        ExpressionLhs<T const&> operator <= ( T const& operand );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( T const& operand )
Catch::ResultBuilder::operator <=	.\catch.hpp	/^        ExpressionLhs<bool> operator <= ( bool value );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool value )
Catch::ResultBuilder::operator ||	.\catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
Catch::ResultBuilder::react	.\catch.hpp	/^        void react();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
Catch::ResultBuilder::reconstructExpression	.\catch.hpp	/^        std::string reconstructExpression() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::setLhs	.\catch.hpp	/^        ResultBuilder& setLhs( std::string const& lhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& lhs )
Catch::ResultBuilder::setOp	.\catch.hpp	/^        ResultBuilder& setOp( std::string const& op );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& op )
Catch::ResultBuilder::setResultType	.\catch.hpp	/^        ResultBuilder& setResultType( ResultWas::OfType result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType result )
Catch::ResultBuilder::setResultType	.\catch.hpp	/^        ResultBuilder& setResultType( bool result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool result )
Catch::ResultBuilder::setRhs	.\catch.hpp	/^        ResultBuilder& setRhs( std::string const& rhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& rhs )
Catch::ResultBuilder::shouldDebugBreak	.\catch.hpp	/^        bool shouldDebugBreak() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::useActiveException	.\catch.hpp	/^        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal )
Catch::ResultDisposition	.\catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	s	namespace:Catch
Catch::ResultDisposition::ContinueOnFailure	.\catch.hpp	/^        ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultDisposition::FalseTest	.\catch.hpp	/^        FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultDisposition::Flags	.\catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	g	struct:Catch::ResultDisposition	access:public
Catch::ResultDisposition::Normal	.\catch.hpp	/^        Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultDisposition::SuppressFail	.\catch.hpp	/^        SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultWas	.\catch.hpp	/^    struct ResultWas { enum OfType {$/;"	s	namespace:Catch
Catch::ResultWas::DidntThrowException	.\catch.hpp	/^        DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Exception	.\catch.hpp	/^        Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::ExplicitFailure	.\catch.hpp	/^        ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::ExpressionFailed	.\catch.hpp	/^        ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::FailureBit	.\catch.hpp	/^        FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::FatalErrorCondition	.\catch.hpp	/^        FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Info	.\catch.hpp	/^        Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::OfType	.\catch.hpp	/^    struct ResultWas { enum OfType {$/;"	g	struct:Catch::ResultWas	access:public
Catch::ResultWas::Ok	.\catch.hpp	/^        Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::ThrewException	.\catch.hpp	/^        ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Unknown	.\catch.hpp	/^        Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Warning	.\catch.hpp	/^        Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
Catch::SafeBool	.\catch.hpp	/^    class SafeBool {$/;"	c	namespace:Catch
Catch::SafeBool::makeSafe	.\catch.hpp	/^        static type makeSafe( bool value ) {$/;"	f	class:Catch::SafeBool	access:public	signature:( bool value )
Catch::SafeBool::trueValue	.\catch.hpp	/^        void trueValue() const {}$/;"	f	class:Catch::SafeBool	access:private	signature:() const
Catch::SharedImpl	.\catch.hpp	/^    struct SharedImpl : T {$/;"	s	namespace:Catch	inherits:T
Catch::SharedImpl::SharedImpl	.\catch.hpp	/^        SharedImpl() : m_rc( 0 ){}$/;"	f	struct:Catch::SharedImpl	access:public	signature:()
Catch::SharedImpl::addRef	.\catch.hpp	/^        virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
Catch::SharedImpl::m_rc	.\catch.hpp	/^        mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl	access:public
Catch::SharedImpl::release	.\catch.hpp	/^        virtual void release() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
Catch::SourceLineInfo	.\catch.hpp	/^    struct SourceLineInfo {$/;"	s	namespace:Catch
Catch::SourceLineInfo::SourceLineInfo	.\catch.hpp	/^        SourceLineInfo( SourceLineInfo && )                  = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
Catch::SourceLineInfo::SourceLineInfo	.\catch.hpp	/^        SourceLineInfo( SourceLineInfo const& other );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other )
Catch::SourceLineInfo::SourceLineInfo	.\catch.hpp	/^        SourceLineInfo( char const* _file, std::size_t _line );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( char const* _file, std::size_t _line )
Catch::SourceLineInfo::SourceLineInfo	.\catch.hpp	/^        SourceLineInfo();$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:()
Catch::SourceLineInfo::empty	.\catch.hpp	/^        bool empty() const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:() const
Catch::SourceLineInfo::file	.\catch.hpp	/^        std::string file;$/;"	m	struct:Catch::SourceLineInfo	access:public
Catch::SourceLineInfo::line	.\catch.hpp	/^        std::size_t line;$/;"	m	struct:Catch::SourceLineInfo	access:public
Catch::SourceLineInfo::operator <	.\catch.hpp	/^        bool operator < ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
Catch::SourceLineInfo::operator =	.\catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo && )     = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
Catch::SourceLineInfo::operator =	.\catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& )
Catch::SourceLineInfo::operator ==	.\catch.hpp	/^        bool operator == ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
Catch::StreamEndStop	.\catch.hpp	/^    struct StreamEndStop {$/;"	s	namespace:Catch
Catch::StreamEndStop::operator +	.\catch.hpp	/^        std::string operator+() {$/;"	f	struct:Catch::StreamEndStop	access:public	signature:()
Catch::StringMaker	.\catch.hpp	/^struct StringMaker :$/;"	s	namespace:Catch	inherits:Detail::StringMakerBase
Catch::StringMaker	.\catch.hpp	/^struct StringMaker<R C::*> {$/;"	s	namespace:Catch
Catch::StringMaker	.\catch.hpp	/^struct StringMaker<T*> {$/;"	s	namespace:Catch
Catch::StringMaker::convert	.\catch.hpp	/^    static std::string convert( R C::* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( R C::* p )
Catch::StringMaker::convert	.\catch.hpp	/^    static std::string convert( U* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( U* p )
Catch::TestFailureException	.\catch.hpp	/^    struct TestFailureException{};$/;"	s	namespace:Catch
Catch::TestFunction	.\catch.hpp	/^typedef void(*TestFunction)();$/;"	t	namespace:Catch
Catch::TupleDetail	.\catch.hpp	/^namespace TupleDetail {$/;"	n	namespace:Catch
Catch::alwaysFalse	.\catch.hpp	/^    inline bool alwaysFalse() { return false; }$/;"	f	namespace:Catch	signature:()
Catch::alwaysTrue	.\catch.hpp	/^    inline bool alwaysTrue() { return true; }$/;"	f	namespace:Catch	signature:()
Catch::cleanUpContext	.\catch.hpp	/^    void cleanUpContext();$/;"	p	namespace:Catch	signature:()
Catch::contains	.\catch.hpp	/^    bool contains( std::string const& s, std::string const& infix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& infix )
Catch::createGeneratorsForTest	.\catch.hpp	/^    IGeneratorsForTest* createGeneratorsForTest();$/;"	p	namespace:Catch	signature:()
Catch::createStream	.\catch.hpp	/^    Stream createStream( std::string const& streamName );$/;"	p	namespace:Catch	signature:( std::string const& streamName )
Catch::deleteAll	.\catch.hpp	/^    inline void deleteAll( ContainerT& container ) {$/;"	f	namespace:Catch	signature:( ContainerT& container )
Catch::deleteAllValues	.\catch.hpp	/^    inline void deleteAllValues( AssociativeContainerT& container ) {$/;"	f	namespace:Catch	signature:( AssociativeContainerT& container )
Catch::endsWith	.\catch.hpp	/^    bool endsWith( std::string const& s, std::string const& suffix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& suffix )
Catch::filterTests	.\catch.hpp	/^    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );$/;"	p	namespace:Catch	signature:( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config )
Catch::getCurrentContext	.\catch.hpp	/^    IContext& getCurrentContext();$/;"	p	namespace:Catch	signature:()
Catch::getCurrentMutableContext	.\catch.hpp	/^    IMutableContext& getCurrentMutableContext();$/;"	p	namespace:Catch	signature:()
Catch::isFalseTest	.\catch.hpp	/^    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
Catch::isJustInfo	.\catch.hpp	/^    inline bool isJustInfo( int flags ) {$/;"	f	namespace:Catch	signature:( int flags )
Catch::isOk	.\catch.hpp	/^    inline bool isOk( ResultWas::OfType resultType ) {$/;"	f	namespace:Catch	signature:( ResultWas::OfType resultType )
Catch::isTrue	.\catch.hpp	/^    inline bool isTrue( bool value ){ return value; }$/;"	f	namespace:Catch	signature:( bool value )
Catch::matchTest	.\catch.hpp	/^    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );$/;"	p	namespace:Catch	signature:( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config )
Catch::operator +	.\catch.hpp	/^    T const& operator + ( T const& value, StreamEndStop ) {$/;"	f	namespace:Catch	signature:( T const& value, StreamEndStop )
Catch::operator <<	.\catch.hpp	/^    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );$/;"	p	namespace:Catch	signature:( std::ostream& os, SourceLineInfo const& info )
Catch::operator |	.\catch.hpp	/^    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {$/;"	f	namespace:Catch	signature:( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs )
Catch::pluralise	.\catch.hpp	/^    struct pluralise {$/;"	s	namespace:Catch
Catch::pluralise::m_count	.\catch.hpp	/^        std::size_t m_count;$/;"	m	struct:Catch::pluralise	access:public
Catch::pluralise::m_label	.\catch.hpp	/^        std::string m_label;$/;"	m	struct:Catch::pluralise	access:public
Catch::pluralise::operator <<	.\catch.hpp	/^        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );$/;"	p	struct:Catch::pluralise	access:friend	signature:( std::ostream& os, pluralise const& pluraliser )
Catch::pluralise::pluralise	.\catch.hpp	/^        pluralise( std::size_t count, std::string const& label );$/;"	p	struct:Catch::pluralise	access:public	signature:( std::size_t count, std::string const& label )
Catch::registerTestCase	.\catch.hpp	/^void registerTestCase$/;"	p	namespace:Catch	signature:( ITestCase* testCase, char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
Catch::registerTestCaseFunction	.\catch.hpp	/^void registerTestCaseFunction$/;"	p	namespace:Catch	signature:( TestFunction function, SourceLineInfo const& lineInfo, NameAndDesc const& nameAndDesc )
Catch::replaceInPlace	.\catch.hpp	/^    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );$/;"	p	namespace:Catch	signature:( std::string& str, std::string const& replaceThis, std::string const& withThis )
Catch::rngSeed	.\catch.hpp	/^    unsigned int rngSeed();$/;"	p	namespace:Catch	signature:()
Catch::seedRng	.\catch.hpp	/^    void seedRng( IConfig const& config );$/;"	p	namespace:Catch	signature:( IConfig const& config )
Catch::shouldContinueOnFailure	.\catch.hpp	/^    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
Catch::shouldSuppressFailure	.\catch.hpp	/^    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
Catch::startsWith	.\catch.hpp	/^    bool startsWith( std::string const& s, std::string const& prefix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& prefix )
Catch::std::getAllTestCasesSorted	.\catch.hpp	/^    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );$/;"	p	class:Catch::std	signature:( IConfig const& config )
Catch::throwLogicError	.\catch.hpp	/^    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );$/;"	p	namespace:Catch	signature:( std::string const& message, SourceLineInfo const& locationInfo )
Catch::toLower	.\catch.hpp	/^    std::string toLower( std::string const& s );$/;"	p	namespace:Catch	signature:( std::string const& s )
Catch::toLowerInPlace	.\catch.hpp	/^    void toLowerInPlace( std::string& s );$/;"	p	namespace:Catch	signature:( std::string& s )
Catch::toString	.\catch.hpp	/^    std::string toString( NSObject* const& nsObject );$/;"	p	namespace:Catch	signature:( NSObject* const& nsObject )
Catch::toString	.\catch.hpp	/^    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );$/;"	p	namespace:Catch	signature:( NSString * CATCH_ARC_STRONG const& nsstring )
Catch::toString	.\catch.hpp	/^    std::string toString( NSString const * const& nsstring );$/;"	p	namespace:Catch	signature:( NSString const * const& nsstring )
Catch::toString	.\catch.hpp	/^std::string toString( T const& value );$/;"	p	namespace:Catch	signature:( T const& value )
Catch::toString	.\catch.hpp	/^std::string toString( bool value );$/;"	p	namespace:Catch	signature:( bool value )
Catch::toString	.\catch.hpp	/^std::string toString( char value );$/;"	p	namespace:Catch	signature:( char value )
Catch::toString	.\catch.hpp	/^std::string toString( char* const value );$/;"	p	namespace:Catch	signature:( char* const value )
Catch::toString	.\catch.hpp	/^std::string toString( const char* const value );$/;"	p	namespace:Catch	signature:( const char* const value )
Catch::toString	.\catch.hpp	/^std::string toString( const double value );$/;"	p	namespace:Catch	signature:( const double value )
Catch::toString	.\catch.hpp	/^std::string toString( const float value );$/;"	p	namespace:Catch	signature:( const float value )
Catch::toString	.\catch.hpp	/^std::string toString( const wchar_t* const value );$/;"	p	namespace:Catch	signature:( const wchar_t* const value )
Catch::toString	.\catch.hpp	/^std::string toString( int value );$/;"	p	namespace:Catch	signature:( int value )
Catch::toString	.\catch.hpp	/^std::string toString( long long value );$/;"	p	namespace:Catch	signature:( long long value )
Catch::toString	.\catch.hpp	/^std::string toString( signed char value );$/;"	p	namespace:Catch	signature:( signed char value )
Catch::toString	.\catch.hpp	/^std::string toString( std::nullptr_t );$/;"	p	namespace:Catch	signature:( std::nullptr_t )
Catch::toString	.\catch.hpp	/^std::string toString( std::string const& value );$/;"	p	namespace:Catch	signature:( std::string const& value )
Catch::toString	.\catch.hpp	/^std::string toString( std::vector<T,Allocator> const& v ) {$/;"	f	namespace:Catch	signature:( std::vector<T,Allocator> const& v )
Catch::toString	.\catch.hpp	/^std::string toString( std::wstring const& value );$/;"	p	namespace:Catch	signature:( std::wstring const& value )
Catch::toString	.\catch.hpp	/^std::string toString( unsigned char value );$/;"	p	namespace:Catch	signature:( unsigned char value )
Catch::toString	.\catch.hpp	/^std::string toString( unsigned int value );$/;"	p	namespace:Catch	signature:( unsigned int value )
Catch::toString	.\catch.hpp	/^std::string toString( unsigned long long value );$/;"	p	namespace:Catch	signature:( unsigned long long value )
Catch::toString	.\catch.hpp	/^std::string toString( unsigned long value );$/;"	p	namespace:Catch	signature:( unsigned long value )
Catch::toString	.\catch.hpp	/^std::string toString( wchar_t* const value );$/;"	p	namespace:Catch	signature:( wchar_t* const value )
Catch::trim	.\catch.hpp	/^    std::string trim( std::string const& str );$/;"	p	namespace:Catch	signature:( std::string const& str )
Choice	.\catch.hpp	/^    struct CaseSensitive { enum Choice {$/;"	g	struct:Catch::CaseSensitive	access:public
Contains	.\catch.hpp	/^            Contains( Contains const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:( Contains const& other )
Contains	.\catch.hpp	/^            Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Contains	.\catch.hpp	/^        struct Contains : MatcherImpl<Contains, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
Contains	.\catch.hpp	/^    inline Impl::StdString::Contains    Contains( const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Contains	.\catch.hpp	/^    inline Impl::StdString::Contains    Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
ContinueOnFailure	.\catch.hpp	/^        ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
CopyableStream	.\catch.hpp	/^        CopyableStream( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
CopyableStream	.\catch.hpp	/^        CopyableStream() {}$/;"	f	struct:Catch::CopyableStream	access:public	signature:()
CopyableStream	.\catch.hpp	/^    struct CopyableStream {$/;"	s	namespace:Catch
DFS	.\leet_199.cc	/^    void DFS(TreeNode* root, int &h, vector<int> &vec){$/;"	f	class:Solution	access:public	signature:(TreeNode* root, int &h, vector<int> &vec)
DLEN	.\baidu.cpp	16;"	d	file:
Detail	.\catch.hpp	/^namespace Detail {$/;"	n	namespace:Catch
DidntThrowException	.\catch.hpp	/^        DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
DirectoryOfThisScript	.\.ycm_extra_conf.py	/^def DirectoryOfThisScript():$/;"	f	access:public
EndsWith	.\catch.hpp	/^            EndsWith( EndsWith const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:( EndsWith const& other )
EndsWith	.\catch.hpp	/^            EndsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
EndsWith	.\catch.hpp	/^        struct EndsWith : MatcherImpl<EndsWith, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
EndsWith	.\catch.hpp	/^    inline Impl::StdString::EndsWith    EndsWith( const char* substr ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* substr )
EndsWith	.\catch.hpp	/^    inline Impl::StdString::EndsWith    EndsWith( std::string const& substr ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& substr )
EnumStringMaker	.\catch.hpp	/^    struct EnumStringMaker$/;"	s	namespace:Catch::Detail
EnumStringMaker	.\catch.hpp	/^    struct EnumStringMaker<T,true>$/;"	s	namespace:Catch::Detail
Equals	.\catch.hpp	/^            Equals( Equals const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:( Equals const& other )
Equals	.\catch.hpp	/^            Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Equals	.\catch.hpp	/^        struct Equals : MatcherImpl<Equals, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
Equals	.\catch.hpp	/^    inline Impl::StdString::Equals      Equals( const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Equals	.\catch.hpp	/^    inline Impl::StdString::Equals      Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
Evaluator	.\catch.hpp	/^    class Evaluator{};$/;"	c	namespace:Catch::Internal
Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	.\catch.hpp	/^    struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Exception	.\catch.hpp	/^        Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
ExplicitFailure	.\catch.hpp	/^        ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
ExprComponents	.\catch.hpp	/^            ExprComponents() : testFalse( false ) {}$/;"	f	struct:Catch::ResultBuilder::ExprComponents	access:public	signature:()
ExprComponents	.\catch.hpp	/^        struct ExprComponents {$/;"	s	class:Catch::ResultBuilder	access:private
ExpressionFailed	.\catch.hpp	/^        ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
ExpressionType	.\catch.hpp	/^        typedef ExpressionT ExpressionType;$/;"	t	struct:Catch::Matchers::Impl::Matcher	access:public
FailureBit	.\catch.hpp	/^        FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
FalseTest	.\catch.hpp	/^        FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
FalseType	.\catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	s	namespace:Catch::Detail
FatalErrorCondition	.\catch.hpp	/^        FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
Flags	.\catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	g	struct:Catch::ResultDisposition	access:public
FlagsForFile	.\.ycm_extra_conf.py	/^def FlagsForFile( filename, **kwargs ):$/;"	f	access:public
GIVEN	.\catch.hpp	10476;"	d
Generic	.\catch.hpp	/^    namespace Generic {$/;"	n	namespace:Catch::Matchers::Impl
GetCompilationInfoForFile	.\.ycm_extra_conf.py	/^def GetCompilationInfoForFile( filename ):$/;"	f	access:public
IContext	.\catch.hpp	/^    struct IContext$/;"	s	namespace:Catch
IGeneratorInfo	.\catch.hpp	/^    struct IGeneratorInfo {$/;"	s	namespace:Catch
IGeneratorsForTest	.\catch.hpp	/^    struct IGeneratorsForTest {$/;"	s	namespace:Catch
IMutableContext	.\catch.hpp	/^    struct IMutableContext : IContext$/;"	s	namespace:Catch	inherits:IContext
INTERNAL_CATCH_ELSE	.\catch.hpp	2076;"	d
INTERNAL_CATCH_GENERATE	.\catch.hpp	2507;"	d
INTERNAL_CATCH_IF	.\catch.hpp	2071;"	d
INTERNAL_CATCH_INFO	.\catch.hpp	2151;"	d
INTERNAL_CATCH_LINESTR	.\catch.hpp	2505;"	d
INTERNAL_CATCH_LINESTR2	.\catch.hpp	2504;"	d
INTERNAL_CATCH_METHOD_AS_TEST_CASE	.\catch.hpp	713;"	d
INTERNAL_CATCH_MSG	.\catch.hpp	2133;"	d
INTERNAL_CATCH_NO_THROW	.\catch.hpp	2081;"	d
INTERNAL_CATCH_REACT	.\catch.hpp	2052;"	d
INTERNAL_CATCH_REGISTER_LEGACY_REPORTER	.\catch.hpp	8875;"	d
INTERNAL_CATCH_REGISTER_LISTENER	.\catch.hpp	8881;"	d
INTERNAL_CATCH_REGISTER_REPORTER	.\catch.hpp	8878;"	d
INTERNAL_CATCH_REGISTER_TESTCASE	.\catch.hpp	729;"	d
INTERNAL_CATCH_SECTION	.\catch.hpp	2322;"	d
INTERNAL_CATCH_STRINGIFY	.\catch.hpp	72;"	d
INTERNAL_CATCH_STRINGIFY2	.\catch.hpp	71;"	d
INTERNAL_CATCH_TEST	.\catch.hpp	2057;"	d
INTERNAL_CATCH_TESTCASE	.\catch.hpp	709;"	d
INTERNAL_CATCH_TESTCASE2	.\catch.hpp	705;"	d
INTERNAL_CATCH_TEST_CASE_METHOD	.\catch.hpp	725;"	d
INTERNAL_CATCH_TEST_CASE_METHOD2	.\catch.hpp	717;"	d
INTERNAL_CATCH_THROWS	.\catch.hpp	2095;"	d
INTERNAL_CATCH_THROWS_AS	.\catch.hpp	2112;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION	.\catch.hpp	2610;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION2	.\catch.hpp	2605;"	d
INTERNAL_CATCH_UNIQUE_NAME	.\catch.hpp	66;"	d
INTERNAL_CATCH_UNIQUE_NAME	.\catch.hpp	68;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE	.\catch.hpp	64;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE2	.\catch.hpp	63;"	d
INTERNAL_CHECK_THAT	.\catch.hpp	2155;"	d
IShared	.\catch.hpp	/^    struct IShared : NonCopyable {$/;"	s	namespace:Catch	inherits:NonCopyable
ITestCase	.\catch.hpp	/^    struct ITestCase : IShared {$/;"	s	namespace:Catch	inherits:IShared
ITestCaseRegistry	.\catch.hpp	/^    struct ITestCaseRegistry {$/;"	s	namespace:Catch
Impl	.\catch.hpp	/^    namespace Impl {$/;"	n	namespace:Catch::Matchers
Info	.\catch.hpp	/^        Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Internal	.\catch.hpp	/^namespace Internal {$/;"	n	namespace:Catch
IsEqualTo	.\catch.hpp	/^        IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThan	.\catch.hpp	/^        IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThanOrEqualTo	.\catch.hpp	/^        IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
IsHeaderFile	.\.ycm_extra_conf.py	/^def IsHeaderFile( filename ):$/;"	f	access:public
IsLessThan	.\catch.hpp	/^        IsLessThan,$/;"	e	enum:Catch::Internal::Operator
IsLessThanOrEqualTo	.\catch.hpp	/^        IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsNotEqualTo	.\catch.hpp	/^        IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsStreamInsertable	.\catch.hpp	/^    struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
ListNode	.\leet_148.cc	/^    ListNode(int x): val(x),next(NULL){}$/;"	f	struct:ListNode	access:public	signature:(int x)
ListNode	.\leet_148.cc	/^struct ListNode{$/;"	s	file:
ListNode::ListNode	.\leet_148.cc	/^    ListNode(int x): val(x),next(NULL){}$/;"	f	struct:ListNode	access:public	signature:(int x)
ListNode::next	.\leet_148.cc	/^    ListNode *next;$/;"	m	struct:ListNode	file:	access:public
ListNode::val	.\leet_148.cc	/^    int val;$/;"	m	struct:ListNode	file:	access:public
MAX	.\wap\submit\wap1_generate.cc	8;"	d	file:
MAX	.\wap\submit\wap2_generate.cc	8;"	d	file:
MAX	.\wap\submit\wap2_sol.cc	6;"	d	file:
MAX	.\wap\wap1\map_test1_flat.cc	5;"	d	file:
MAX	.\wap\wap1\wap1_generate.cc	8;"	d	file:
MAX	.\wap\wap2\wap2_generate.cc	8;"	d	file:
MAXINT	.\indeed\sol4.cc	5;"	d	file:
MAXN	.\baidu.cpp	14;"	d	file:
MAXSIZE	.\baidu.cpp	15;"	d	file:
MMM	.\Astar\R2B_p3.cc	7;"	d	file:
MakeRelativePathsInFlagsAbsolute	.\.ycm_extra_conf.py	/^def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):$/;"	f	access:public
Matcher	.\catch.hpp	/^    struct Matcher : SharedImpl<IShared>$/;"	s	namespace:Catch::Matchers::Impl	inherits:SharedImpl
MatcherImpl	.\catch.hpp	/^    struct MatcherImpl : Matcher<ExpressionT> {$/;"	s	namespace:Catch::Matchers::Impl	inherits:Matcher
Matchers	.\catch.hpp	/^namespace Matchers {$/;"	n	namespace:Catch
MethodTestCase	.\catch.hpp	/^    MethodTestCase( void (C::*method)() ) : m_method( method ) {}$/;"	f	class:Catch::MethodTestCase	access:public	signature:( void (C::*method)() )
MethodTestCase	.\catch.hpp	/^class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch	inherits:SharedImpl
N	.\baidu.cpp	/^int N;$/;"	v
NOMINMAX	.\catch.hpp	7026;"	d
NameAndDesc	.\catch.hpp	/^    NameAndDesc( const char* _name = "", const char* _description= "" )$/;"	f	struct:Catch::NameAndDesc	access:public	signature:( const char* _name = , const char* _description=  )
NameAndDesc	.\catch.hpp	/^struct NameAndDesc {$/;"	s	namespace:Catch
No	.\catch.hpp	/^        No$/;"	e	enum:Catch::CaseSensitive::Choice
NonCopyable	.\catch.hpp	/^        NonCopyable( NonCopyable && )                  = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
NonCopyable	.\catch.hpp	/^        NonCopyable( NonCopyable const& )              = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
NonCopyable	.\catch.hpp	/^        NonCopyable() {}$/;"	f	class:Catch::NonCopyable	access:protected	signature:()
NonCopyable	.\catch.hpp	/^    class NonCopyable {$/;"	c	namespace:Catch
Normal	.\catch.hpp	/^        Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
Not	.\catch.hpp	/^            Not( Not const& other ) : m_matcher( other.m_matcher ) {}$/;"	f	class:Catch::Matchers::Impl::Generic::Not	access:public	signature:( Not const& other )
Not	.\catch.hpp	/^            explicit Not( Matcher<ExpressionT> const& matcher ) : m_matcher(matcher.clone()) {}$/;"	f	class:Catch::Matchers::Impl::Generic::Not	access:public	signature:( Matcher<ExpressionT> const& matcher )
Not	.\catch.hpp	/^        class Not : public MatcherImpl<Not<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic	inherits:MatcherImpl
Not	.\catch.hpp	/^    inline Impl::Generic::Not<ExpressionT> Not( Impl::Matcher<ExpressionT> const& m ) {$/;"	f	namespace:Catch::Matchers	signature:( Impl::Matcher<ExpressionT> const& m )
NotImplementedException	.\catch.hpp	/^        NotImplementedException( NotImplementedException const& ) {}$/;"	f	class:Catch::NotImplementedException	access:public	signature:( NotImplementedException const& )
NotImplementedException	.\catch.hpp	/^        NotImplementedException( SourceLineInfo const& lineInfo );$/;"	p	class:Catch::NotImplementedException	access:public	signature:( SourceLineInfo const& lineInfo )
NotImplementedException	.\catch.hpp	/^    class NotImplementedException : public std::exception$/;"	c	namespace:Catch	inherits:std::exception
OC_TEST_CASE	.\catch.hpp	3059;"	d
OfType	.\catch.hpp	/^    struct ResultWas { enum OfType {$/;"	g	struct:Catch::ResultWas	access:public
Ok	.\catch.hpp	/^        Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
Operator	.\catch.hpp	/^    enum Operator {$/;"	g	namespace:Catch::Internal
OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	.\catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	.\catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	s	namespace:Catch::Internal
Ptr	.\catch.hpp	/^        Ptr( Ptr const& other ) : m_p( other.m_p ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
Ptr	.\catch.hpp	/^        Ptr( T* p ) : m_p( p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
Ptr	.\catch.hpp	/^        Ptr() : m_p( CATCH_NULL ){}$/;"	f	class:Catch::Ptr	access:public	signature:()
Ptr	.\catch.hpp	/^    class Ptr {$/;"	c	namespace:Catch
ResultBuilder	.\catch.hpp	/^        ResultBuilder(  char const* macroName,$/;"	p	class:Catch::ResultBuilder	access:public	signature:( char const* macroName, SourceLineInfo const& lineInfo, char const* capturedExpression, ResultDisposition::Flags resultDisposition, char const* secondArg =  )
ResultBuilder	.\catch.hpp	/^    class ResultBuilder {$/;"	c	namespace:Catch
ResultDisposition	.\catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	s	namespace:Catch
ResultWas	.\catch.hpp	/^    struct ResultWas { enum OfType {$/;"	s	namespace:Catch
SCENARIO	.\catch.hpp	10470;"	d
SCENARIO_METHOD	.\catch.hpp	10471;"	d
SOURCE_EXTENSIONS	.\.ycm_extra_conf.py	/^SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]$/;"	v
STITCH_CLARA_CLOSE_NAMESPACE	.\catch.hpp	3629;"	d
STITCH_CLARA_CLOSE_NAMESPACE	.\catch.hpp	4630;"	d
STITCH_CLARA_OPEN_NAMESPACE	.\catch.hpp	3618;"	d
STITCH_CLARA_OPEN_NAMESPACE	.\catch.hpp	3628;"	d
STITCH_CLARA_OPEN_NAMESPACE	.\catch.hpp	4629;"	d
STITCH_CLARA_OPEN_NAMESPACE	.\catch.hpp	4633;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	.\catch.hpp	3634;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	.\catch.hpp	3784;"	d
SafeBool	.\catch.hpp	/^    class SafeBool {$/;"	c	namespace:Catch
SharedImpl	.\catch.hpp	/^        SharedImpl() : m_rc( 0 ){}$/;"	f	struct:Catch::SharedImpl	access:public	signature:()
SharedImpl	.\catch.hpp	/^    struct SharedImpl : T {$/;"	s	namespace:Catch	inherits:T
Solution	.\BST.cc	/^class Solution {$/;"	c	file:
Solution	.\Min_Dep_BTree.cpp	/^class Solution {$/;"	c	file:
Solution	.\SurroundedRegions.cpp	/^class Solution{$/;"	c	file:
Solution	.\leet_121.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_132.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_144.cc	/^class Solution {$/;"	c	file:
Solution	.\leet_148.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_199.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_283.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_290.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_309.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_43.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_51.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_77.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_84.cc	/^class Solution{$/;"	c	file:
Solution	.\leet_85.cc	/^class Solution{$/;"	c	file:
Solution	.\leetcode.cpp	/^class Solution{$/;"	c	file:
Solution	.\reversevowel.cpp	/^class Solution{$/;"	c	file:
Solution::DFS	.\leet_199.cc	/^    void DFS(TreeNode* root, int &h, vector<int> &vec){$/;"	f	class:Solution	access:public	signature:(TreeNode* root, int &h, vector<int> &vec)
Solution::bubble_sort	.\leet_148.cc	/^    ListNode* bubble_sort(ListNode* head);$/;"	p	class:Solution	file:	access:public	signature:(ListNode* head)
Solution::canDown	.\leet_51.cc	/^    bool canDown(int cur_row, int cur_col, vector<string> &board){$/;"	f	class:Solution	access:public	signature:(int cur_row, int cur_col, vector<string> &board)
Solution::combine	.\leet_77.cc	/^    vector<vector<int> > combine(int n,int k);$/;"	p	class:Solution	file:	access:public	signature:(int n,int k)
Solution::create	.\leet_148.cc	/^    void create(ListNode* &head, const vector<int> & vec){$/;"	f	class:Solution	access:public	signature:(ListNode* &head, const vector<int> & vec)
Solution::destroy	.\leet_148.cc	/^    void destroy(ListNode* head){$/;"	f	class:Solution	access:public	signature:(ListNode* head)
Solution::inorderTraversal	.\BST.cc	/^        void  inorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::inorderTraversal_stack	.\BST.cc	/^        void inorderTraversal_stack(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::isPal	.\leet_132.cc	/^    bool isPal(string &s, string::iterator it, string::iterator rit){$/;"	f	class:Solution	access:public	signature:(string &s, string::iterator it, string::iterator rit)
Solution::largestRectangleArea	.\leet_84.cc	/^    int largestRectangleArea(vector<int>& heights) {$/;"	f	class:Solution	access:public	signature:(vector<int>& heights)
Solution::lastCut	.\leet_132.cc	/^    int lastCut(string &s){$/;"	f	class:Solution	access:public	signature:(string &s)
Solution::loc	.\SurroundedRegions.cpp	/^    typedef pair<int,int> loc;$/;"	t	class:Solution	file:	access:public
Solution::main	.\leet_283.cc	/^int main(int argc , char** argv)$/;"	f	class:Solution	access:public	signature:(int argc , char** argv)
Solution::maxProfit	.\leet_121.cc	/^    int maxProfit(vector<int>& prices){$/;"	f	class:Solution	access:public	signature:(vector<int>& prices)
Solution::maxProfit	.\leet_309.cc	/^    int maxProfit(vector<int>& prices) {$/;"	f	class:Solution	access:public	signature:(vector<int>& prices)
Solution::maxmalRectangle	.\leet_85.cc	/^    int maxmalRectangle(vector<vector<char> >& matrix);$/;"	p	class:Solution	file:	access:public	signature:(vector<vector<char> >& matrix)
Solution::merge	.\leet_148.cc	/^    ListNode* merge(ListNode* head1, ListNode* head2){$/;"	f	class:Solution	access:public	signature:(ListNode* head1, ListNode* head2)
Solution::merge_sort	.\leet_148.cc	/^    ListNode* merge_sort(ListNode* head){$/;"	f	class:Solution	access:public	signature:(ListNode* head)
Solution::minCut	.\leet_132.cc	/^    int minCut(string s){$/;"	f	class:Solution	access:public	signature:(string s)
Solution::minDepth	.\Min_Dep_BTree.cpp	/^    int minDepth(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::moveZeroes	.\leet_283.cc	/^    void moveZeroes(vector<int>& nums) {$/;"	f	class:Solution	access:public	signature:(vector<int>& nums)
Solution::postorderTraversal	.\BST.cc	/^        void  postorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::postorderTraversal_stack	.\BST.cc	/^        void postorderTraversal_stack(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::preorderTraversal	.\BST.cc	/^        void  preorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::preorderTraversal	.\leet_144.cc	/^    vector<int> preorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::preorderTraversal_stack	.\BST.cc	/^        void preorderTraversal_stack(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::print	.\leet_148.cc	/^    void print(const ListNode* const head) const {$/;"	f	class:Solution	access:public	signature:(const ListNode* const head) const
Solution::reverseVowels	.\reversevowel.cpp	/^	string reverseVowels(string s){$/;"	f	class:Solution	access:public	signature:(string s)
Solution::rightSideView	.\leet_199.cc	/^    vector<int> rightSideView(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
Solution::search	.\SurroundedRegions.cpp	/^    void search(int a, int b, int m, int n, queue<loc> &q, vector<vector<char>>& board){$/;"	f	class:Solution	access:public	signature:(int a, int b, int m, int n, queue<loc> &q, vector<vector<char>>& board)
Solution::solve	.\SurroundedRegions.cpp	/^    void solve(vector<vector<char>>& board){$/;"	f	class:Solution	access:public	signature:(vector<vector<char>>& board)
Solution::solveNQueens	.\leet_51.cc	/^    vector<vector<string> > solveNQueens(int n){$/;"	f	class:Solution	access:public	signature:(int n)
Solution::sortList	.\leet_148.cc	/^    ListNode* sortList(ListNode* head);$/;"	p	class:Solution	file:	access:public	signature:(ListNode* head)
Solution::stringmap	.\leet_290.cc	/^    typedef unordered_map<char,string> stringmap;$/;"	t	class:Solution	file:	access:public
Solution::wordPattern	.\leet_290.cc	/^    bool wordPattern(string pattern, string str) {$/;"	f	class:Solution	access:public	signature:(string pattern, string str)
SourceLineInfo	.\catch.hpp	/^        SourceLineInfo( SourceLineInfo && )                  = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
SourceLineInfo	.\catch.hpp	/^        SourceLineInfo( SourceLineInfo const& other );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other )
SourceLineInfo	.\catch.hpp	/^        SourceLineInfo( char const* _file, std::size_t _line );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( char const* _file, std::size_t _line )
SourceLineInfo	.\catch.hpp	/^        SourceLineInfo();$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:()
SourceLineInfo	.\catch.hpp	/^    struct SourceLineInfo {$/;"	s	namespace:Catch
StartsWith	.\catch.hpp	/^            StartsWith( StartsWith const& other ) : m_data( other.m_data ){}$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:( StartsWith const& other )
StartsWith	.\catch.hpp	/^            StartsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
StartsWith	.\catch.hpp	/^        struct StartsWith : MatcherImpl<StartsWith, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString	inherits:MatcherImpl
StartsWith	.\catch.hpp	/^    inline Impl::StdString::StartsWith  StartsWith( const char* substr ) {$/;"	f	namespace:Catch::Matchers	signature:( const char* substr )
StartsWith	.\catch.hpp	/^    inline Impl::StdString::StartsWith  StartsWith( std::string const& substr ) {$/;"	f	namespace:Catch::Matchers	signature:( std::string const& substr )
StdString	.\catch.hpp	/^    namespace StdString {$/;"	n	namespace:Catch::Matchers::Impl
StreamEndStop	.\catch.hpp	/^    struct StreamEndStop {$/;"	s	namespace:Catch
StringMaker	.\catch.hpp	/^struct StringMaker :$/;"	s	namespace:Catch	inherits:Detail::StringMakerBase
StringMaker	.\catch.hpp	/^struct StringMaker<R C::*> {$/;"	s	namespace:Catch
StringMaker	.\catch.hpp	/^struct StringMaker<T*> {$/;"	s	namespace:Catch
StringMakerBase	.\catch.hpp	/^    struct StringMakerBase {$/;"	s	namespace:Catch::Detail
StringMakerBase	.\catch.hpp	/^    struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
SuppressFail	.\catch.hpp	/^        SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
TBC_TEXT_FORMAT_CONSOLE_WIDTH	.\catch.hpp	4838;"	d
TBC_TEXT_FORMAT_H_INCLUDED	.\catch.hpp	3641;"	d
THEN	.\catch.hpp	10479;"	d
TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED	.\catch.hpp	2613;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED	.\catch.hpp	7254;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED	.\catch.hpp	821;"	d
TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED	.\catch.hpp	763;"	d
TWOBLUECUBES_CATCH_CLARA_H_INCLUDED	.\catch.hpp	3608;"	d
TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED	.\catch.hpp	3088;"	d
TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED	.\catch.hpp	7768;"	d
TWOBLUECUBES_CATCH_COMMON_H_INCLUDED	.\catch.hpp	61;"	d
TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED	.\catch.hpp	79;"	d
TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED	.\catch.hpp	3091;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED	.\catch.hpp	4996;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED	.\catch.hpp	6993;"	d
TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED	.\catch.hpp	451;"	d
TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED	.\catch.hpp	6806;"	d
TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED	.\catch.hpp	7906;"	d
TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED	.\catch.hpp	1987;"	d
TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED	.\catch.hpp	10303;"	d
TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED	.\catch.hpp	1283;"	d
TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED	.\catch.hpp	6655;"	d
TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED	.\catch.hpp	1280;"	d
TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED	.\catch.hpp	5789;"	d
TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED	.\catch.hpp	2330;"	d
TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED	.\catch.hpp	7180;"	d
TWOBLUECUBES_CATCH_HPP_INCLUDED	.\catch.hpp	14;"	d
TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED	.\catch.hpp	3074;"	d
TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED	.\catch.hpp	1950;"	d
TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED	.\catch.hpp	3346;"	d
TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED	.\catch.hpp	2510;"	d
TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED	.\catch.hpp	454;"	d
TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED	.\catch.hpp	2516;"	d
TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED	.\catch.hpp	5053;"	d
TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED	.\catch.hpp	2036;"	d
TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED	.\catch.hpp	2694;"	d
TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED	.\catch.hpp	603;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED	.\catch.hpp	7590;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED	.\catch.hpp	7593;"	d
TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED	.\catch.hpp	4833;"	d
TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED	.\catch.hpp	883;"	d
TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED	.\catch.hpp	7555;"	d
TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED	.\catch.hpp	1894;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED	.\catch.hpp	6785;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED	.\catch.hpp	58;"	d
TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED	.\catch.hpp	1502;"	d
TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED	.\catch.hpp	2880;"	d
TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED	.\catch.hpp	2718;"	d
TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED	.\catch.hpp	1990;"	d
TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED	.\catch.hpp	478;"	d
TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED	.\catch.hpp	9109;"	d
TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED	.\catch.hpp	6431;"	d
TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED	.\catch.hpp	8563;"	d
TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED	.\catch.hpp	9945;"	d
TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED	.\catch.hpp	9513;"	d
TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED	.\catch.hpp	9304;"	d
TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED	.\catch.hpp	8424;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED	.\catch.hpp	8798;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED	.\catch.hpp	6615;"	d
TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED	.\catch.hpp	8560;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED	.\catch.hpp	8187;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED	.\catch.hpp	766;"	d
TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED	.\catch.hpp	769;"	d
TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED	.\catch.hpp	3085;"	d
TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED	.\catch.hpp	5469;"	d
TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED	.\catch.hpp	7868;"	d
TWOBLUECUBES_CATCH_SECTION_H_INCLUDED	.\catch.hpp	2173;"	d
TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED	.\catch.hpp	2176;"	d
TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED	.\catch.hpp	3407;"	d
TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED	.\catch.hpp	6809;"	d
TWOBLUECUBES_CATCH_STREAM_H_INCLUDED	.\catch.hpp	3404;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED	.\catch.hpp	2697;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED	.\catch.hpp	8332;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED	.\catch.hpp	8335;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED	.\catch.hpp	7334;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED	.\catch.hpp	2797;"	d
TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED	.\catch.hpp	6434;"	d
TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED	.\catch.hpp	5472;"	d
TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED	.\catch.hpp	600;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED	.\catch.hpp	3102;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED	.\catch.hpp	3094;"	d
TWOBLUECUBES_CATCH_TEXT_H_INCLUDED	.\catch.hpp	4836;"	d
TWOBLUECUBES_CATCH_TIMER_H_INCLUDED	.\catch.hpp	2274;"	d
TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED	.\catch.hpp	7995;"	d
TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED	.\catch.hpp	1492;"	d
TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED	.\catch.hpp	2179;"	d
TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED	.\catch.hpp	7521;"	d
TWOBLUECUBES_CATCH_VERSION_H_INCLUDED	.\catch.hpp	6201;"	d
TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED	.\catch.hpp	3110;"	d
TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED	.\catch.hpp	8885;"	d
TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED	.\catch.hpp	3789;"	d
TWOBLUECUBES_CLARA_H_INCLUDED	.\catch.hpp	3627;"	d
TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED	.\catch.hpp	12;"	d
TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED	.\catch.hpp	4846;"	d
TestFailureException	.\catch.hpp	/^    struct TestFailureException{};$/;"	s	namespace:Catch
TestFunction	.\catch.hpp	/^typedef void(*TestFunction)();$/;"	t	namespace:Catch
ThrewException	.\catch.hpp	/^        ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
TreeNode	.\BST.cc	/^    TreeNode(int x)$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode	.\BST.cc	/^struct TreeNode {$/;"	s	file:
TreeNode	.\Min_Dep_BTree.cpp	/^  TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode	.\Min_Dep_BTree.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	.\leet_144.cc	/^    TreeNode(int x)$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode	.\leet_144.cc	/^struct TreeNode {$/;"	s	file:
TreeNode	.\leet_173.cc	/^    TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode	.\leet_173.cc	/^struct TreeNode {$/;"	s	file:
TreeNode	.\leet_199.cc	/^    TreeNode(int x):val(x),left(NULL),right(NULL){}$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode	.\leet_199.cc	/^struct TreeNode{$/;"	s	file:
TreeNode::TreeNode	.\BST.cc	/^    TreeNode(int x)$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode::TreeNode	.\Min_Dep_BTree.cpp	/^  TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode::TreeNode	.\leet_144.cc	/^    TreeNode(int x)$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode::TreeNode	.\leet_173.cc	/^    TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode::TreeNode	.\leet_199.cc	/^    TreeNode(int x):val(x),left(NULL),right(NULL){}$/;"	f	struct:TreeNode	access:public	signature:(int x)
TreeNode::left	.\BST.cc	/^    TreeNode* left;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::left	.\Min_Dep_BTree.cpp	/^  TreeNode *left;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::left	.\leet_144.cc	/^    TreeNode* left;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::left	.\leet_173.cc	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::left	.\leet_199.cc	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::right	.\BST.cc	/^    TreeNode* right;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::right	.\Min_Dep_BTree.cpp	/^  TreeNode *right;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::right	.\leet_144.cc	/^    TreeNode* right;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::right	.\leet_173.cc	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::right	.\leet_199.cc	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::val	.\BST.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::val	.\Min_Dep_BTree.cpp	/^  int val;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::val	.\leet_144.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::val	.\leet_173.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
TreeNode::val	.\leet_199.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
TrueType	.\catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	s	namespace:Catch::Detail
TupleDetail	.\catch.hpp	/^namespace TupleDetail {$/;"	n	namespace:Catch
Unknown	.\catch.hpp	/^        Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
WHEN	.\catch.hpp	10477;"	d
Warning	.\catch.hpp	/^        Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
Yes	.\catch.hpp	/^        Yes,$/;"	e	enum:Catch::CaseSensitive::Choice
__TRIETREE__	.\wap\BTrie.cc	2;"	d	file:
__TRIETREE__	.\wap\submit\BTrie.cc	2;"	d	file:
__XORTRIETREE__	.\wap\submit\xortrie.cc	2;"	d	file:
__XORTRIETREE__	.\wap\xortrie.cc	2;"	d	file:
a	.\baidu.cpp	/^	int a[500];    \/\/可以控制大数的位数 $/;"	m	class:BigNum	file:	access:private
add	.\catch.hpp	/^            AllOf& add( Matcher<ExpressionT> const& matcher ) {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( Matcher<ExpressionT> const& matcher )
add	.\catch.hpp	/^            AnyOf& add( Matcher<ExpressionT> const& matcher ) {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( Matcher<ExpressionT> const& matcher )
addRef	.\catch.hpp	/^        virtual void addRef() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
addRef	.\catch.hpp	/^        virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
adjustString	.\catch.hpp	/^            std::string adjustString( std::string const& str ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	access:public	signature:( std::string const& str ) const
advanceGeneratorsForCurrentTest	.\catch.hpp	/^        virtual bool advanceGeneratorsForCurrentTest() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
allowThrows	.\catch.hpp	/^        bool allowThrows() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
alwaysFalse	.\catch.hpp	/^    inline bool alwaysFalse() { return false; }$/;"	f	namespace:Catch	signature:()
alwaysTrue	.\catch.hpp	/^    inline bool alwaysTrue() { return true; }$/;"	f	namespace:Catch	signature:()
applyEvaluator	.\catch.hpp	/^    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
arcSafeRelease	.\catch.hpp	/^inline void arcSafeRelease( NSObject* ){}$/;"	f	signature:( NSObject* )
arcSafeRelease	.\catch.hpp	/^inline void arcSafeRelease( NSObject* obj ) {$/;"	f	signature:( NSObject* obj )
arcSafeRelease	.\catch.hpp	/^void arcSafeRelease( NSObject* obj );$/;"	p	signature:( NSObject* obj )
areas	.\indeed\sol4.cc	/^int areas[21][21]={0};$/;"	v
bigint	.\wap\submit\wap2_generate.cc	/^typedef unsigned long long bigint;$/;"	t	file:
bigint	.\wap\submit\wap2_sol.cc	/^typedef unsigned long long bigint;$/;"	t	file:
bigint	.\wap\submit\xortrie.cc	/^typedef unsigned long long bigint;$/;"	t	file:
bigint	.\wap\wap2\wap2_generate.cc	/^typedef unsigned long long bigint;$/;"	t	file:
bigint	.\wap\wap2\wap2_sol.cc	/^typedef unsigned long long bigint;$/;"	t	file:
bigint	.\wap\xortrie.cc	/^typedef unsigned long long bigint;$/;"	t	file:
bigmod	.\Astar\p1.cc	/^int bigmod(int x , ll m , int k){$/;"	f	signature:(int x , ll m , int k)
bitvec	.\wap\submit\wap2_sol.cc	/^typedef std::bitset<40> bitvec;$/;"	t	file:
bitvec	.\wap\submit\xortrie.cc	/^typedef std::bitset<40> bitvec;$/;"	t	file:
bitvec	.\wap\wap2\wap2_sol.cc	/^typedef std::bitset<40> bitvec;$/;"	t	file:
bitvec	.\wap\xortrie.cc	/^typedef std::bitset<40> bitvec;$/;"	t	file:
bubble_sort	.\leet_148.cc	/^    ListNode* bubble_sort(ListNode* head);$/;"	p	class:Solution	file:	access:public	signature:(ListNode* head)
build	.\catch.hpp	/^        AssertionResult build() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
canDown	.\leet_51.cc	/^    bool canDown(int cur_row, int cur_col, vector<string> &board){$/;"	f	class:Solution	access:public	signature:(int cur_row, int cur_col, vector<string> &board)
captureExpectedException	.\catch.hpp	/^        void captureExpectedException( Matchers::Impl::Matcher<std::string> const& matcher );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( Matchers::Impl::Matcher<std::string> const& matcher )
captureExpectedException	.\catch.hpp	/^        void captureExpectedException( std::string const& expectedMessage );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& expectedMessage )
captureExpression	.\catch.hpp	/^        void captureExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
captureResult	.\catch.hpp	/^        void captureResult( ResultWas::OfType resultType );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType resultType )
capturedExpression	.\catch.hpp	/^        std::string capturedExpression;$/;"	m	struct:Catch::AssertionInfo	access:public
choco	.\indeed\sol4.cc	/^int choco[21][21]={0};$/;"	v
clean	.\wap\BTrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
clean	.\wap\BTrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
clean	.\wap\submit\BTrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
clean	.\wap\submit\BTrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
clean	.\wap\submit\wap2_sol.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
clean	.\wap\submit\wap2_sol.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
clean	.\wap\submit\wap_sol1.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
clean	.\wap\submit\wap_sol1.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
clean	.\wap\submit\xortrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
clean	.\wap\submit\xortrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
clean	.\wap\xortrie.cc	/^		void clean();$/;"	p	class:BTrie	file:	access:public	signature:()
clean	.\wap\xortrie.cc	/^void BTrie::clean(){$/;"	f	class:BTrie	signature:()
cleanUpContext	.\catch.hpp	/^    void cleanUpContext();$/;"	p	namespace:Catch	signature:()
clone	.\catch.hpp	/^        virtual Ptr<Matcher<ExpressionT> > clone() const {$/;"	f	struct:Catch::Matchers::Impl::MatcherImpl	access:public	signature:() const
clone	.\catch.hpp	/^        virtual Ptr<Matcher> clone() const = 0;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:() const
combine	.\leet_77.cc	/^    vector<vector<int> > combine(int n,int k);$/;"	p	class:Solution	file:	access:public	signature:(int n,int k)
comp	.\BigNum.cc	/^        int comp(const BigNum &rhs) const;$/;"	p	class:BigNum	file:	access:private	signature:(const BigNum &rhs) const
comp	.\BigNum.cc	/^int BigNum::comp(const BigNum &rhs) const{$/;"	f	class:BigNum	signature:(const BigNum &rhs) const
compare	.\catch.hpp	/^    bool compare( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, int rhs )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, long long rhs )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, long rhs )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, std::nullptr_t )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, T* rhs )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, T* rhs )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, T* rhs )
compare	.\catch.hpp	/^    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( std::nullptr_t, T* rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned char rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned int rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned char rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned int rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned char rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned int rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned long long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long long lhs, unsigned long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, int rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, int rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, int rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, char rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, int rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, long long rhs )
compare	.\catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long long lhs, long rhs )
compilation_database_folder	.\.ycm_extra_conf.py	/^compilation_database_folder = ''$/;"	v
contains	.\catch.hpp	/^    bool contains( std::string const& s, std::string const& infix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& infix )
convert	.\catch.hpp	/^        static std::string convert( T const& ) { return unprintableString; }$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& )
convert	.\catch.hpp	/^        static std::string convert( T const& _value ) {$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& _value )
convert	.\catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& v )
convert	.\catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& v )
convert	.\catch.hpp	/^    static std::string convert( R C::* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( R C::* p )
convert	.\catch.hpp	/^    static std::string convert( U* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( U* p )
count	.\wap\BTrie.cc	/^	int count;$/;"	m	struct:BTrieNode	file:	access:public
count	.\wap\submit\BTrie.cc	/^	int count;$/;"	m	struct:BTrieNode	file:	access:public
count	.\wap\submit\wap_sol1.cc	/^	int count; \/\/ num of leaves below this node$/;"	m	struct:BTrieNode	file:	access:public
create	.\leet_148.cc	/^    void create(ListNode* &head, const vector<int> & vec){$/;"	f	class:Solution	access:public	signature:(ListNode* &head, const vector<int> & vec)
createGeneratorsForTest	.\catch.hpp	/^    IGeneratorsForTest* createGeneratorsForTest();$/;"	p	namespace:Catch	signature:()
createStream	.\catch.hpp	/^    Stream createStream( std::string const& streamName );$/;"	p	namespace:Catch	signature:( std::string const& streamName )
data	.\BigNum.cc	/^        vector<int> data;$/;"	m	class:BigNum	file:	access:private
database	.\.ycm_extra_conf.py	/^  database = None$/;"	v
database	.\.ycm_extra_conf.py	/^  database = ycm_core.CompilationDatabase( compilation_database_folder )$/;"	v
deleteAll	.\catch.hpp	/^    inline void deleteAll( ContainerT& container ) {$/;"	f	namespace:Catch	signature:( ContainerT& container )
deleteAllValues	.\catch.hpp	/^    inline void deleteAllValues( AssociativeContainerT& container ) {$/;"	f	namespace:Catch	signature:( AssociativeContainerT& container )
depth	.\wap\BTrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
depth	.\wap\submit\BTrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
depth	.\wap\submit\wap2_sol.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
depth	.\wap\submit\wap_sol1.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
depth	.\wap\submit\xortrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
depth	.\wap\xortrie.cc	/^		int depth;$/;"	m	class:BTrie	file:	access:private
description	.\catch.hpp	/^    const char* description;$/;"	m	struct:Catch::NameAndDesc	access:public
destroy	.\leet_148.cc	/^    void destroy(ListNode* head){$/;"	f	class:Solution	access:public	signature:(ListNode* head)
destroyTree	.\BST.cc	/^void destroyTree(TreeNode* root) {$/;"	f	signature:(TreeNode* root)
destroyTree	.\leet_144.cc	/^void destroyTree(TreeNode* root) {$/;"	f	signature:(TreeNode* root)
destroyTree	.\leet_173.cc	/^void destroyTree(TreeNode* root)$/;"	f	signature:(TreeNode* root)
divmod	.\BigNum.cc	/^        pair<int,int> divmod(const BigNum &rhs) const;$/;"	p	class:BigNum	file:	access:private	signature:(const BigNum &rhs) const
divmod	.\BigNum.cc	/^pair<int,int> divmod(const BigNum &rhs) const{$/;"	f	signature:(const BigNum &rhs) const
dp	.\Astar\R2B_p3.cc	/^ll dp[10][10]={0};$/;"	v
empty	.\catch.hpp	/^        bool empty() const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:() const
endExpression	.\catch.hpp	/^        void endExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
endsWith	.\catch.hpp	/^    bool endsWith( std::string const& s, std::string const& suffix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& suffix )
evaluate	.\catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs ) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs )
evaluate	.\catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs)
file	.\catch.hpp	/^        std::string file;$/;"	m	struct:Catch::SourceLineInfo	access:public
filterTests	.\catch.hpp	/^    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );$/;"	p	namespace:Catch	signature:( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config )
find	.\wap\BTrie.cc	/^		bool find(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
find	.\wap\BTrie.cc	/^bool BTrie::find(const vec &v){$/;"	f	class:BTrie	signature:(const vec &v)
find	.\wap\submit\BTrie.cc	/^		bool find(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
find	.\wap\submit\BTrie.cc	/^bool BTrie::find(const vec &v){$/;"	f	class:BTrie	signature:(const vec &v)
find	.\wap\submit\wap2_sol.cc	/^		int find(const bitvec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v)
find	.\wap\submit\wap2_sol.cc	/^int BTrie::find(const bitvec &v){$/;"	f	class:BTrie	signature:(const bitvec &v)
find	.\wap\submit\wap_sol1.cc	/^		bool find(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
find	.\wap\submit\wap_sol1.cc	/^bool BTrie::find(const vec &v){$/;"	f	class:BTrie	signature:(const vec &v)
find	.\wap\submit\xortrie.cc	/^		int find(const bitvec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v)
find	.\wap\submit\xortrie.cc	/^int BTrie::find(const bitvec &v){$/;"	f	class:BTrie	signature:(const bitvec &v)
find	.\wap\xortrie.cc	/^		int find(const bitvec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v)
find	.\wap\xortrie.cc	/^int BTrie::find(const bitvec &v){$/;"	f	class:BTrie	signature:(const bitvec &v)
findmax	.\wap\submit\wap_sol1.cc	/^int findmax(const std::vector<int> &v){$/;"	f	signature:(const std::vector<int> &v)
findmax	.\wap\wap1\wap_sol1.cc	/^int findmax(const std::vector<int> &v){$/;"	f	signature:(const std::vector<int> &v)
flags	.\.ycm_extra_conf.py	/^flags = [$/;"	v
generate_one_matrix	.\wap\submit\wap1_generate.cc	/^void generate_one_matrix(int N, int M,int P){$/;"	f	signature:(int N, int M,int P)
generate_one_matrix	.\wap\wap1\map_test1_flat.cc	/^void generate_one_matrix(int N, int M){$/;"	f	signature:(int N, int M)
generate_one_matrix	.\wap\wap1\wap1_generate.cc	/^void generate_one_matrix(int N, int M,int P){$/;"	f	signature:(int N, int M,int P)
generate_sample	.\wap\submit\wap2_generate.cc	/^void generate_sample(const &k){$/;"	f	signature:(const &k)
generate_sample	.\wap\wap2\wap2_generate.cc	/^void generate_sample(const &k){$/;"	f	signature:(const &k)
get	.\catch.hpp	/^        T* get() const{ return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
getAllTestCasesSorted	.\catch.hpp	/^    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );$/;"	p	class:Catch::std	signature:( IConfig const& config )
getAllTests	.\catch.hpp	/^        virtual std::vector<TestCase> const& getAllTests() const = 0;$/;"	p	class:Catch::ITestCaseRegistry::std	access:public	signature:() const
getAllTestsSorted	.\catch.hpp	/^        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;$/;"	p	class:Catch::ITestCaseRegistry::std	access:public	signature:( IConfig const& config ) const
getConfig	.\catch.hpp	/^        virtual Ptr<IConfig const> getConfig() const = 0;$/;"	p	struct:Catch::IContext	access:public	signature:() const
getCurrentContext	.\catch.hpp	/^    IContext& getCurrentContext();$/;"	p	namespace:Catch	signature:()
getCurrentIndex	.\catch.hpp	/^        virtual std::size_t getCurrentIndex() const = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:() const
getCurrentMutableContext	.\catch.hpp	/^    IMutableContext& getCurrentMutableContext();$/;"	p	namespace:Catch	signature:()
getExpandedExpression	.\catch.hpp	/^        std::string getExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getExpression	.\catch.hpp	/^        std::string getExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getExpressionInMacro	.\catch.hpp	/^        std::string getExpressionInMacro() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getGeneratorIndex	.\catch.hpp	/^        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;$/;"	p	struct:Catch::IContext	access:public	signature:( std::string const& fileInfo, size_t totalSize )
getGeneratorInfo	.\catch.hpp	/^        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:( std::string const& fileInfo, std::size_t size )
getMessage	.\catch.hpp	/^        std::string getMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	.\catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	.\catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getResultCapture	.\catch.hpp	/^        virtual IResultCapture* getResultCapture() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
getResultType	.\catch.hpp	/^        ResultWas::OfType getResultType() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getRunner	.\catch.hpp	/^        virtual IRunner* getRunner() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
getSourceInfo	.\catch.hpp	/^        SourceLineInfo getSourceInfo() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getTestMacroName	.\catch.hpp	/^        std::string getTestMacroName() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
get_max_count	.\wap\BTrie.cc	/^        int  get_max_count(int i){$/;"	f	class:BTrie	access:public	signature:(int i)
get_max_count	.\wap\submit\BTrie.cc	/^        int  get_max_count(int i){$/;"	f	class:BTrie	access:public	signature:(int i)
get_max_count	.\wap\submit\wap_sol1.cc	/^        int  get_max_count(int i){$/;"	f	class:BTrie	access:public	signature:(int i)
handleResult	.\catch.hpp	/^        void handleResult( AssertionResult const& result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( AssertionResult const& result )
hasExpandedExpression	.\catch.hpp	/^        bool hasExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
hasExpression	.\catch.hpp	/^        bool hasExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
hasMessage	.\catch.hpp	/^        bool hasMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
hasNext	.\leet_173.cc	/^        bool hasNext()$/;"	f	class:BSTIterator	access:public	signature:()
in	.\wap\submit\wap2_sol.cc	/^std::vector<bigint> in(MAX); $/;"	p	file:	signature:(MAX)
index	.\wap\submit\wap2_sol.cc	/^	int index; \/\/ remember the index of leaves in the vector$/;"	m	struct:BTrieNode	file:	access:public
index	.\wap\submit\xortrie.cc	/^	int index;$/;"	m	struct:BTrieNode	file:	access:public
index	.\wap\xortrie.cc	/^	int index;$/;"	m	struct:BTrieNode	file:	access:public
inorderTraversal	.\BST.cc	/^        void  inorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
inorderTraversal_stack	.\BST.cc	/^        void inorderTraversal_stack(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
insert	.\wap\BTrie.cc	/^		void insert(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
insert	.\wap\BTrie.cc	/^		void insert(const vec &v, const vec &order);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v, const vec &order)
insert	.\wap\BTrie.cc	/^void BTrie::insert(const vec &a){$/;"	f	class:BTrie	signature:(const vec &a)
insert	.\wap\BTrie.cc	/^void BTrie::insert(const vec &a, const vec &order){$/;"	f	class:BTrie	signature:(const vec &a, const vec &order)
insert	.\wap\submit\BTrie.cc	/^		void insert(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
insert	.\wap\submit\BTrie.cc	/^		void insert(const vec &v, const vec &order);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v, const vec &order)
insert	.\wap\submit\BTrie.cc	/^void BTrie::insert(const vec &a){$/;"	f	class:BTrie	signature:(const vec &a)
insert	.\wap\submit\BTrie.cc	/^void BTrie::insert(const vec &a, const vec &order){$/;"	f	class:BTrie	signature:(const vec &a, const vec &order)
insert	.\wap\submit\wap2_sol.cc	/^		void insert(const bitvec &v,int index);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v,int index)
insert	.\wap\submit\wap2_sol.cc	/^void BTrie::insert(const bitvec &a,int index){$/;"	f	class:BTrie	signature:(const bitvec &a,int index)
insert	.\wap\submit\wap_sol1.cc	/^		void insert(const vec &v);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v)
insert	.\wap\submit\wap_sol1.cc	/^		void insert(const vec &v, const vec &order);$/;"	p	class:BTrie	file:	access:public	signature:(const vec &v, const vec &order)
insert	.\wap\submit\wap_sol1.cc	/^void BTrie::insert(const vec &a){$/;"	f	class:BTrie	signature:(const vec &a)
insert	.\wap\submit\wap_sol1.cc	/^void BTrie::insert(const vec &a, const vec &order){$/;"	f	class:BTrie	signature:(const vec &a, const vec &order)
insert	.\wap\submit\xortrie.cc	/^		void insert(const bitvec &v,int index);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v,int index)
insert	.\wap\submit\xortrie.cc	/^void BTrie::insert(const bitvec &a,int index){$/;"	f	class:BTrie	signature:(const bitvec &a,int index)
insert	.\wap\xortrie.cc	/^		void insert(const bitvec &v,int index);$/;"	p	class:BTrie	file:	access:public	signature:(const bitvec &v,int index)
insert	.\wap\xortrie.cc	/^void BTrie::insert(const bitvec &a,int index){$/;"	f	class:BTrie	signature:(const bitvec &a,int index)
int_matrix	.\wap\submit\wap_sol1.cc	/^typedef std::vector<std::vector<int>>  int_matrix;$/;"	t	file:
int_matrix	.\wap\wap1\wap_sol1.cc	/^typedef std::vector<std::vector<int>>  int_matrix;$/;"	t	file:
invoke	.\catch.hpp	/^        virtual void invoke () const = 0;$/;"	p	struct:Catch::ITestCase	access:public	signature:() const
invoke	.\catch.hpp	/^    virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase	access:public	signature:() const
isEmpty	.\wap\BTrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
isEmpty	.\wap\BTrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
isEmpty	.\wap\submit\BTrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
isEmpty	.\wap\submit\BTrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
isEmpty	.\wap\submit\wap2_sol.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
isEmpty	.\wap\submit\wap2_sol.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
isEmpty	.\wap\submit\wap_sol1.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
isEmpty	.\wap\submit\wap_sol1.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
isEmpty	.\wap\submit\xortrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
isEmpty	.\wap\submit\xortrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
isEmpty	.\wap\xortrie.cc	/^		bool isEmpty();$/;"	p	class:BTrie	file:	access:public	signature:()
isEmpty	.\wap\xortrie.cc	/^bool BTrie::isEmpty(){$/;"	f	class:BTrie	signature:()
isFalseTest	.\catch.hpp	/^    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
isJustInfo	.\catch.hpp	/^    inline bool isJustInfo( int flags ) {$/;"	f	namespace:Catch	signature:( int flags )
isOk	.\catch.hpp	/^        bool isOk() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
isOk	.\catch.hpp	/^    inline bool isOk( ResultWas::OfType resultType ) {$/;"	f	namespace:Catch	signature:( ResultWas::OfType resultType )
isPal	.\leet_132.cc	/^    bool isPal(string &s, string::iterator it, string::iterator rit){$/;"	f	class:Solution	access:public	signature:(string &s, string::iterator it, string::iterator rit)
isTrue	.\catch.hpp	/^    inline bool isTrue( bool value ){ return value; }$/;"	f	namespace:Catch	signature:( bool value )
largestRectangleArea	.\leet_84.cc	/^    int largestRectangleArea(vector<int>& heights) {$/;"	f	class:Solution	access:public	signature:(vector<int>& heights)
lastCut	.\leet_132.cc	/^    int lastCut(string &s){$/;"	f	class:Solution	access:public	signature:(string &s)
lcs	.\wap\onsite\lcs.cc	/^int lcs(string s1, string s2){$/;"	f	signature:(string s1, string s2)
left	.\BST.cc	/^    TreeNode* left;$/;"	m	struct:TreeNode	file:	access:public
left	.\Min_Dep_BTree.cpp	/^  TreeNode *left;$/;"	m	struct:TreeNode	file:	access:public
left	.\leet_144.cc	/^    TreeNode* left;$/;"	m	struct:TreeNode	file:	access:public
left	.\leet_173.cc	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:	access:public
left	.\leet_199.cc	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:	access:public
left	.\wap\BTrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
left	.\wap\submit\BTrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
left	.\wap\submit\wap2_sol.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
left	.\wap\submit\wap_sol1.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
left	.\wap\submit\xortrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
left	.\wap\xortrie.cc	/^	BTrieNode* left;$/;"	m	struct:BTrieNode	file:	access:public
len	.\BigNum.cc	/^        int len;$/;"	m	class:BigNum	file:	access:private
len	.\baidu.cpp	/^	int len;       \/\/大数长度$/;"	m	class:BigNum	file:	access:private
lhs	.\catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
line	.\catch.hpp	/^        std::size_t line;$/;"	m	struct:Catch::SourceLineInfo	access:public
lineInfo	.\catch.hpp	/^        SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo	access:public
ll	.\Astar\R2B_p3.cc	/^typedef long long ll;$/;"	t	file:
ll	.\Astar\p1.cc	/^typedef long long ll;$/;"	t	file:
ll	.\indeed\sol2.cc	/^typedef long long ll;$/;"	t	file:
loc	.\SurroundedRegions.cpp	/^    typedef pair<int,int> loc;$/;"	t	class:Solution	file:	access:public
m_assertionInfo	.\catch.hpp	/^        AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder	access:private
m_caseSensitivity	.\catch.hpp	/^            CaseSensitive::Choice m_caseSensitivity;$/;"	m	struct:Catch::Matchers::Impl::StdString::CasedString	access:public
m_count	.\catch.hpp	/^        std::size_t m_count;$/;"	m	struct:Catch::pluralise	access:public
m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::Contains	access:public
m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public
m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::Equals	access:public
m_data	.\catch.hpp	/^            CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public
m_data	.\catch.hpp	/^        AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder	access:private
m_exprComponents	.\catch.hpp	/^        } m_exprComponents;$/;"	m	class:Catch::ResultBuilder	typeref:struct:Catch::ResultBuilder::ExprComponents	access:private
m_info	.\catch.hpp	/^        AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult	access:protected
m_label	.\catch.hpp	/^        std::string m_label;$/;"	m	struct:Catch::pluralise	access:public
m_lineInfo	.\catch.hpp	/^        SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException	access:private
m_matcher	.\catch.hpp	/^            Ptr< Matcher<ExpressionT> > m_matcher;$/;"	m	class:Catch::Matchers::Impl::Generic::Not	access:private
m_matchers	.\catch.hpp	/^            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;$/;"	m	class:Catch::Matchers::Impl::Generic::AllOf	access:private
m_matchers	.\catch.hpp	/^            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;$/;"	m	class:Catch::Matchers::Impl::Generic::AnyOf	access:private
m_method	.\catch.hpp	/^    void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase	access:private
m_p	.\catch.hpp	/^        T* m_p;$/;"	m	class:Catch::Ptr	access:private
m_rc	.\catch.hpp	/^        mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl	access:public
m_resultData	.\catch.hpp	/^        AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult	access:protected
m_shouldDebugBreak	.\catch.hpp	/^        bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder	access:private
m_shouldThrow	.\catch.hpp	/^        bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder	access:private
m_str	.\catch.hpp	/^            std::string m_str;$/;"	m	struct:Catch::Matchers::Impl::StdString::CasedString	access:public
m_stream	.\catch.hpp	/^        CopyableStream m_stream;$/;"	m	class:Catch::ResultBuilder	access:private
m_what	.\catch.hpp	/^        std::string m_what;$/;"	m	class:Catch::NotImplementedException	access:private
macroName	.\catch.hpp	/^        std::string macroName;$/;"	m	struct:Catch::AssertionInfo	access:public
main	.\Astar\R2B_p3.cc	/^int main(int argc, char** argv){$/;"	f	signature:(int argc, char** argv)
main	.\Astar\p1.cc	/^int main(int argc, char** argv){$/;"	f	signature:(int argc, char** argv)
main	.\BST.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\BigNum.cc	/^int main(int argc, char** argv){$/;"	f	signature:(int argc, char** argv)
main	.\Min_Dep_BTree.cpp	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\SurroundedRegions.cpp	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\baidu.cpp	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\indeed\sol1.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\indeed\sol2.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\indeed\sol4.cc	/^int main(int argc, char** argv){$/;"	f	signature:(int argc, char** argv)
main	.\jsk\sol1.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_121.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_132.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_144.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\leet_148.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_173.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_199.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_283.cc	/^int main(int argc , char** argv)$/;"	f	class:Solution	access:public	signature:(int argc , char** argv)
main	.\leet_290.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_309.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_43.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_51.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_77.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_84.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leet_85.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\leetcode.cpp	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\maxSubSum.cc	/^int main(int argc,char** argv){$/;"	f	signature:(int argc,char** argv)
main	.\reversevowel.cpp	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\test_ptr.cc	/^int main(int argn , char** argv)$/;"	f	signature:(int argn , char** argv)
main	.\validpreorder.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\wap\BTrie.cc	/^int main(int argc , char ** argv){$/;"	f	signature:(int argc , char ** argv)
main	.\wap\onsite\lcs.cc	/^int main(int argc, char** argv){$/;"	f	signature:(int argc, char** argv)
main	.\wap\onsite\maxLenSubSeq.cc	/^int main(int argc,char** argv){$/;"	f	signature:(int argc,char** argv)
main	.\wap\onsite\maxSubSum.cc	/^int main(int argc,char** argv){$/;"	f	signature:(int argc,char** argv)
main	.\wap\submit\BTrie.cc	/^int main(int argc , char ** argv){$/;"	f	signature:(int argc , char ** argv)
main	.\wap\submit\wap1_generate.cc	/^int main(int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	.\wap\submit\wap2_generate.cc	/^int main(int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	.\wap\submit\wap2_sol.cc	/^int main(int argc, char** argv)$/;"	f	signature:(int argc, char** argv)
main	.\wap\submit\wap_sol1.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\wap\submit\xortrie.cc	/^int main(int argc , char ** argv){$/;"	f	signature:(int argc , char ** argv)
main	.\wap\wap1\map_test1_flat.cc	/^int main(int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	.\wap\wap1\wap1_generate.cc	/^int main(int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	.\wap\wap1\wap_sol1.cc	/^int main(int argc , char** argv)$/;"	f	signature:(int argc , char** argv)
main	.\wap\wap2\wap2_generate.cc	/^int main(int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	.\wap\wap2\wap2_sol.cc	/^int main(int argc, char** argv)$/;"	f	signature:(int argc, char** argv)
main	.\wap\xortrie.cc	/^int main(int argc , char ** argv){$/;"	f	signature:(int argc , char ** argv)
makeSafe	.\catch.hpp	/^        static type makeSafe( bool value ) {$/;"	f	class:Catch::SafeBool	access:public	signature:( bool value )
makeString	.\catch.hpp	/^        inline std::string makeString( const char* str ) { return str ? std::string( str ) : std::string(); }$/;"	f	namespace:Catch::Matchers::Impl::StdString	signature:( const char* str )
makeString	.\catch.hpp	/^        inline std::string makeString( std::string const& str ) { return str; }$/;"	f	namespace:Catch::Matchers::Impl::StdString	signature:( std::string const& str )
match	.\catch.hpp	/^            virtual bool match( ExpressionT const& expr ) const$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( ExpressionT const& expr ) const
match	.\catch.hpp	/^            virtual bool match( ExpressionT const& expr ) const$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( ExpressionT const& expr ) const
match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:( std::string const& expr ) const
match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:( std::string const& expr ) const
match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:( std::string const& expr ) const
match	.\catch.hpp	/^            virtual bool match( std::string const& expr ) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:( std::string const& expr ) const
match	.\catch.hpp	/^        virtual bool match( ExpressionT const& expr ) const = 0;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:( ExpressionT const& expr ) const
matchTest	.\catch.hpp	/^    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );$/;"	p	namespace:Catch	signature:( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config )
maxLen	.\wap\onsite\maxLenSubSeq.cc	/^int maxLen(const vector<int> &vec){$/;"	f	signature:(const vector<int> &vec)
maxProfit	.\leet_121.cc	/^    int maxProfit(vector<int>& prices){$/;"	f	class:Solution	access:public	signature:(vector<int>& prices)
maxProfit	.\leet_309.cc	/^    int maxProfit(vector<int>& prices) {$/;"	f	class:Solution	access:public	signature:(vector<int>& prices)
max_count	.\wap\BTrie.cc	/^        vec max_count;$/;"	m	class:BTrie	file:	access:private
max_count	.\wap\submit\BTrie.cc	/^        vec max_count;$/;"	m	class:BTrie	file:	access:private
max_count	.\wap\submit\wap_sol1.cc	/^        vec max_count; \/\/ the max num of leaves below at each level$/;"	m	class:BTrie	file:	access:private
max_sum	.\maxSubSum.cc	/^int max_sum(const vector<int> &vec, int &begin, int &end){$/;"	f	signature:(const vector<int> &vec, int &begin, int &end)
max_sum	.\wap\onsite\maxSubSum.cc	/^int max_sum(const vector<int> &vec, int &begin, int &end){$/;"	f	signature:(const vector<int> &vec, int &begin, int &end)
max_xor	.\wap\submit\wap2_sol.cc	/^std::tuple<int,int,bigint> max_xor(const std::vector<bigint> &vec, int n){$/;"	f	signature:(const std::vector<bigint> &vec, int n)
max_xor	.\wap\wap2\wap2_sol.cc	/^std::tuple<int,int,bigint> max_xor(const std::vector<bigint> &vec){$/;"	f	signature:(const std::vector<bigint> &vec)
maxmalRectangle	.\leet_85.cc	/^    int maxmalRectangle(vector<vector<char> >& matrix);$/;"	p	class:Solution	file:	access:public	signature:(vector<vector<char> >& matrix)
merge	.\leet_148.cc	/^    ListNode* merge(ListNode* head1, ListNode* head2){$/;"	f	class:Solution	access:public	signature:(ListNode* head1, ListNode* head2)
merge_sort	.\leet_148.cc	/^    ListNode* merge_sort(ListNode* head){$/;"	f	class:Solution	access:public	signature:(ListNode* head)
message	.\catch.hpp	/^        std::string message;$/;"	m	struct:Catch::AssertionResultData	access:public
minCut	.\leet_132.cc	/^    int minCut(string s){$/;"	f	class:Solution	access:public	signature:(string s)
minDepth	.\Min_Dep_BTree.cpp	/^    int minDepth(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
min_cost	.\indeed\sol4.cc	/^int min_cost[21][21][21][21]={0};$/;"	v
min_pixels	.\wap\submit\wap_sol1.cc	/^int min_pixels(const int_matrix &mat){$/;"	f	signature:(const int_matrix &mat)
min_pixels	.\wap\wap1\wap_sol1.cc	/^int min_pixels(const int_matrix &mat){$/;"	f	signature:(const int_matrix &mat)
moveNext	.\catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
moveNext	.\catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
moveZeroes	.\leet_283.cc	/^    void moveZeroes(vector<int>& nums) {$/;"	f	class:Solution	access:public	signature:(vector<int>& nums)
name	.\catch.hpp	/^    const char* name;$/;"	m	struct:Catch::NameAndDesc	access:public
next	.\leet_148.cc	/^    ListNode *next;$/;"	m	struct:ListNode	file:	access:public
next	.\leet_173.cc	/^        int next()$/;"	f	class:BSTIterator	access:public	signature:()
op	.\catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
opCast	.\catch.hpp	/^    inline T& opCast(T const& t) { return const_cast<T&>(t); }$/;"	f	namespace:Catch::Internal	signature:(T const& t)
opCast	.\catch.hpp	/^    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }$/;"	f	namespace:Catch::Internal	signature:(std::nullptr_t)
operator !	.\catch.hpp	/^        Generic::Not<ExpressionT> operator ! () const;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:() const
operator !	.\catch.hpp	/^        bool operator !() const { return m_p == CATCH_NULL; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator !	.\catch.hpp	/^    Generic::Not<ExpressionT> Matcher<ExpressionT>::operator ! () const {$/;"	f	class:Catch::Matchers::Impl::Matcher	signature:() const
operator %	.\baidu.cpp	/^	int    operator%(const int  &) const;    \/\/大数对一个int类型的变量进行取模运算    $/;"	p	class:BigNum	file:	access:public	signature:(const int &) const
operator %	.\baidu.cpp	/^int BigNum::operator %(const int & b) const    \/\/大数对一个int类型的变量进行取模运算    $/;"	f	class:BigNum	signature:(const int & b) const
operator &&	.\catch.hpp	/^            AllOf operator && ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:( Matcher<ExpressionT> const& other ) const
operator &&	.\catch.hpp	/^        Generic::AllOf<ExpressionT> operator && ( Matcher<ExpressionT> const& other ) const;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:( Matcher<ExpressionT> const& other ) const
operator &&	.\catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
operator &&	.\catch.hpp	/^    Generic::AllOf<ExpressionT> Matcher<ExpressionT>::operator && ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Matcher	signature:( Matcher<ExpressionT> const& other ) const
operator *	.\BigNum.cc	/^        friend BigNum operator*(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator *	.\BigNum.cc	/^BigNum operator*(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator *	.\baidu.cpp	/^	BigNum operator*(const BigNum &) const;   \/\/重载乘法运算符，两个大数之间的相乘运算 $/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &) const
operator *	.\baidu.cpp	/^BigNum BigNum::operator*(const BigNum & T) const   \/\/两个大数之间的相乘运算 $/;"	f	class:BigNum	signature:(const BigNum & T) const
operator *	.\catch.hpp	/^        T& operator*() const { return *m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator *=	.\BigNum.cc	/^        BigNum& operator*=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
operator *=	.\BigNum.cc	/^BigNum& BigNum::operator*=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
operator +	.\BigNum.cc	/^        friend BigNum operator+(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator +	.\BigNum.cc	/^        friend BigNum operator+(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &rhs)
operator +	.\BigNum.cc	/^BigNum operator+(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator +	.\baidu.cpp	/^	BigNum operator+(const BigNum &) const;   \/\/重载加法运算符，两个大数之间的相加运算 $/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &) const
operator +	.\baidu.cpp	/^BigNum BigNum::operator+(const BigNum & T) const   \/\/两个大数之间的相加运算$/;"	f	class:BigNum	signature:(const BigNum & T) const
operator +	.\catch.hpp	/^        std::string operator+() {$/;"	f	struct:Catch::StreamEndStop	access:public	signature:()
operator +	.\catch.hpp	/^    T const& operator + ( T const& value, StreamEndStop ) {$/;"	f	namespace:Catch	signature:( T const& value, StreamEndStop )
operator +=	.\BigNum.cc	/^        BigNum& operator+=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
operator +=	.\BigNum.cc	/^BigNum& BigNum::operator+=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
operator -	.\BigNum.cc	/^        friend BigNum operator-(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator -	.\BigNum.cc	/^        friend BigNum operator-(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &rhs)
operator -	.\BigNum.cc	/^BigNum operator-(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator -	.\BigNum.cc	/^BigNum operator-(const BigNum &rhs){$/;"	f	signature:(const BigNum &rhs)
operator -	.\baidu.cpp	/^	BigNum operator-(const BigNum &) const;   \/\/重载减法运算符，两个大数之间的相减运算 $/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &) const
operator -	.\baidu.cpp	/^BigNum BigNum::operator-(const BigNum & T) const   \/\/两个大数之间的相减运算 $/;"	f	class:BigNum	signature:(const BigNum & T) const
operator -=	.\BigNum.cc	/^        BigNum& operator-=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
operator -=	.\BigNum.cc	/^BigNum& BigNum::operator-=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
operator ->	.\catch.hpp	/^        T* operator->() const { return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator /	.\BigNum.cc	/^        friend BigNum operator\/(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator /	.\baidu.cpp	/^	BigNum operator\/(const int   &) const;    \/\/重载除法运算符，大数对一个整数进行相除运算$/;"	p	class:BigNum	file:	access:public	signature:(const int &) const
operator /	.\baidu.cpp	/^BigNum BigNum::operator\/(const int & b) const   \/\/大数对一个整数进行相除运算$/;"	f	class:BigNum	signature:(const int & b) const
operator /=	.\BigNum.cc	/^        BigNum& operator\/=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
operator /=	.\BigNum.cc	/^BigNum& BigNum::operator\/=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
operator <	.\BigNum.cc	/^        friend bool operator<(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator <	.\BigNum.cc	/^bool operator<(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator <	.\catch.hpp	/^        bool operator < ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
operator <<	.\BigNum.cc	/^        friend ostream& operator<<(ostream& os,const BigNum &obj);$/;"	p	class:BigNum	file:	access:friend	signature:(ostream& os,const BigNum &obj)
operator <<	.\BigNum.cc	/^ostream& operator<<(ostream& os, const BigNum &obj){$/;"	f	signature:(ostream& os, const BigNum &obj)
operator <<	.\baidu.cpp	/^	friend ostream& operator<<(ostream&,  BigNum&);   \/\/重载输出运算符$/;"	p	class:BigNum	file:	access:friend	signature:(ostream&, BigNum&)
operator <<	.\baidu.cpp	/^ostream& operator<<(ostream& out,  BigNum& b)   \/\/重载输出运算符$/;"	f	signature:(ostream& out, BigNum& b)
operator <<	.\catch.hpp	/^        ResultBuilder& operator << ( T const& value ) {$/;"	f	class:Catch::ResultBuilder	access:public	signature:( T const& value )
operator <<	.\catch.hpp	/^        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );$/;"	p	struct:Catch::pluralise	access:friend	signature:( std::ostream& os, pluralise const& pluraliser )
operator <<	.\catch.hpp	/^    FalseType operator<<( std::ostream const&, BorgType const& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream const&, BorgType const& )
operator <<	.\catch.hpp	/^    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );$/;"	p	namespace:Catch	signature:( std::ostream& os, SourceLineInfo const& info )
operator <=	.\BigNum.cc	/^        friend bool operator<=(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator <=	.\BigNum.cc	/^bool operator<=(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator <=	.\catch.hpp	/^        ExpressionLhs<T const&> operator <= ( T const& operand );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( T const& operand )
operator <=	.\catch.hpp	/^        ExpressionLhs<bool> operator <= ( bool value );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool value )
operator =	.\BigNum.cc	/^        BigNum& operator=(const BigNum &rhs);$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &rhs)
operator =	.\BigNum.cc	/^BigNum& BigNum::operator=(const BigNum &rhs){$/;"	f	class:BigNum	signature:(const BigNum &rhs)
operator =	.\baidu.cpp	/^	BigNum &operator=(const BigNum &);   \/\/重载赋值运算符，大数之间进行赋值运算$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum &)
operator =	.\baidu.cpp	/^BigNum & BigNum::operator=(const BigNum & n)   \/\/重载赋值运算符，大数之间进行赋值运算$/;"	f	class:BigNum	signature:(const BigNum & n)
operator =	.\catch.hpp	/^         AssertionResult& operator = ( AssertionResult && )     = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
operator =	.\catch.hpp	/^         AssertionResult& operator = ( AssertionResult const& ) = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
operator =	.\catch.hpp	/^        CopyableStream& operator=( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
operator =	.\catch.hpp	/^        NonCopyable& operator = ( NonCopyable && )     = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
operator =	.\catch.hpp	/^        NonCopyable& operator = ( NonCopyable const& ) = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
operator =	.\catch.hpp	/^        Ptr& operator = ( Ptr const& other ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
operator =	.\catch.hpp	/^        Ptr& operator = ( T* p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
operator =	.\catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo && )     = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
operator =	.\catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& )
operator =	.\catch.hpp	/^    void operator= ( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
operator ==	.\BigNum.cc	/^        friend bool operator==(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator ==	.\BigNum.cc	/^bool operator==(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator ==	.\catch.hpp	/^        bool operator == ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
operator >	.\BigNum.cc	/^        friend bool operator>(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator >	.\BigNum.cc	/^bool operator>(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator >	.\baidu.cpp	/^	bool   operator>(const BigNum & T)const;   \/\/大数和另一个大数的大小比较$/;"	p	class:BigNum	file:	access:public	signature:(const BigNum & T) const
operator >	.\baidu.cpp	/^	bool   operator>(const int & t)const;      \/\/大数和一个int类型的变量的大小比较$/;"	p	class:BigNum	file:	access:public	signature:(const int & t) const
operator >	.\baidu.cpp	/^bool BigNum::operator >(const int & t) const    \/\/大数和一个int类型的变量的大小比较$/;"	f	class:BigNum	signature:(const int & t) const
operator >	.\baidu.cpp	/^bool BigNum::operator>(const BigNum & T) const   \/\/大数和另一个大数的大小比较$/;"	f	class:BigNum	signature:(const BigNum & T) const
operator >=	.\BigNum.cc	/^        friend bool operator>=(const BigNum &lhs, const BigNum &rhs);$/;"	p	class:BigNum	file:	access:friend	signature:(const BigNum &lhs, const BigNum &rhs)
operator >=	.\BigNum.cc	/^bool operator>=(const BigNum &lhs, const BigNum &rhs){$/;"	f	signature:(const BigNum &lhs, const BigNum &rhs)
operator >>	.\baidu.cpp	/^	friend istream& operator>>(istream&,  BigNum&);   \/\/重载输入运算符$/;"	p	class:BigNum	file:	access:friend	signature:(istream&, BigNum&)
operator >>	.\baidu.cpp	/^istream& operator>>(istream & in,  BigNum & b)   \/\/重载输入运算符$/;"	f	signature:(istream & in, BigNum & b)
operator SafeBool::type	.\catch.hpp	/^        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator ^	.\baidu.cpp	/^	BigNum operator^(const int  &) const;    \/\/大数的n次方运算$/;"	p	class:BigNum	file:	access:public	signature:(const int &) const
operator ^	.\baidu.cpp	/^BigNum BigNum::operator^(const int & n) const    \/\/大数的n次方运算$/;"	f	class:BigNum	signature:(const int & n) const
operator |	.\catch.hpp	/^    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {$/;"	f	namespace:Catch	signature:( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs )
operator ||	.\catch.hpp	/^            AnyOf operator || ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:( Matcher<ExpressionT> const& other ) const
operator ||	.\catch.hpp	/^        Generic::AnyOf<ExpressionT> operator || ( Matcher<ExpressionT> const& other ) const;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:( Matcher<ExpressionT> const& other ) const
operator ||	.\catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
operator ||	.\catch.hpp	/^    Generic::AnyOf<ExpressionT> Matcher<ExpressionT>::operator || ( Matcher<ExpressionT> const& other ) const {$/;"	f	class:Catch::Matchers::Impl::Matcher	signature:( Matcher<ExpressionT> const& other ) const
os	.\.ycm_extra_conf.py	/^import os$/;"	i
oss	.\catch.hpp	/^        std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream	access:public
performOptionalSelector	.\catch.hpp	/^id performOptionalSelector( id obj, SEL sel );$/;"	p	signature:( id obj, SEL sel )
performOptionalSelector	.\catch.hpp	/^inline id performOptionalSelector( id obj, SEL sel ) {$/;"	f	signature:( id obj, SEL sel )
permute_str	.\indeed\sol1.cc	/^set<string> permute_str(string str){$/;"	f	signature:(string str)
pluralise	.\catch.hpp	/^        pluralise( std::size_t count, std::string const& label );$/;"	p	struct:Catch::pluralise	access:public	signature:( std::size_t count, std::string const& label )
pluralise	.\catch.hpp	/^    struct pluralise {$/;"	s	namespace:Catch
postorderTraversal	.\BST.cc	/^        void  postorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
postorderTraversal_stack	.\BST.cc	/^        void postorderTraversal_stack(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
preorderTraversal	.\BST.cc	/^        void  preorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
preorderTraversal	.\leet_144.cc	/^    vector<int> preorderTraversal(TreeNode* root) {$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
preorderTraversal_stack	.\BST.cc	/^        void preorderTraversal_stack(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
print	.\baidu.cpp	/^	void print();       \/\/输出大数$/;"	p	class:BigNum	file:	access:public	signature:()
print	.\baidu.cpp	/^void BigNum::print()    \/\/输出大数$/;"	f	class:BigNum	signature:()
print	.\leet_148.cc	/^    void print(const ListNode* const head) const {$/;"	f	class:Solution	access:public	signature:(const ListNode* const head) const
rangeToString	.\catch.hpp	/^    std::string rangeToString( InputIterator first, InputIterator last );$/;"	p	namespace:Catch::Detail	signature:( InputIterator first, InputIterator last )
rawMemoryToString	.\catch.hpp	/^    inline std::string rawMemoryToString( const T& object ) {$/;"	f	namespace:Catch::Detail	signature:( const T& object )
rawMemoryToString	.\catch.hpp	/^    std::string rawMemoryToString( const void *object, std::size_t size );$/;"	p	namespace:Catch::Detail	signature:( const void *object, std::size_t size )
react	.\catch.hpp	/^        void react();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
reconstructExpression	.\catch.hpp	/^        std::string reconstructExpression() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
reconstructedExpression	.\catch.hpp	/^        std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData	access:public
registerTestCase	.\catch.hpp	/^void registerTestCase$/;"	p	namespace:Catch	signature:( ITestCase* testCase, char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
registerTestCaseFunction	.\catch.hpp	/^void registerTestCaseFunction$/;"	p	namespace:Catch	signature:( TestFunction function, SourceLineInfo const& lineInfo, NameAndDesc const& nameAndDesc )
release	.\catch.hpp	/^        virtual void release() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
release	.\catch.hpp	/^        virtual void release() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
remove	.\wap\BTrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
remove	.\wap\BTrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
remove	.\wap\submit\BTrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
remove	.\wap\submit\BTrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
remove	.\wap\submit\wap2_sol.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
remove	.\wap\submit\wap2_sol.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
remove	.\wap\submit\wap_sol1.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
remove	.\wap\submit\wap_sol1.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
remove	.\wap\submit\xortrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
remove	.\wap\submit\xortrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
remove	.\wap\xortrie.cc	/^		void remove(BTrieNode* &p);$/;"	p	class:BTrie	file:	access:private	signature:(BTrieNode* &p)
remove	.\wap\xortrie.cc	/^void BTrie::remove(BTrieNode* &p){$/;"	f	class:BTrie	signature:(BTrieNode* &p)
replaceInPlace	.\catch.hpp	/^    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );$/;"	p	namespace:Catch	signature:( std::string& str, std::string const& replaceThis, std::string const& withThis )
reset	.\catch.hpp	/^        void reset() {$/;"	f	class:Catch::Ptr	access:public	signature:()
resultDisposition	.\catch.hpp	/^        ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo	access:public
resultType	.\catch.hpp	/^        ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData	access:public
reverseVowels	.\reversevowel.cpp	/^	string reverseVowels(string s){$/;"	f	class:Solution	access:public	signature:(string s)
rhs	.\catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
right	.\BST.cc	/^    TreeNode* right;$/;"	m	struct:TreeNode	file:	access:public
right	.\Min_Dep_BTree.cpp	/^  TreeNode *right;$/;"	m	struct:TreeNode	file:	access:public
right	.\leet_144.cc	/^    TreeNode* right;$/;"	m	struct:TreeNode	file:	access:public
right	.\leet_173.cc	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:	access:public
right	.\leet_199.cc	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:	access:public
right	.\wap\BTrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
right	.\wap\submit\BTrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
right	.\wap\submit\wap2_sol.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
right	.\wap\submit\wap_sol1.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
right	.\wap\submit\xortrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
right	.\wap\xortrie.cc	/^	BTrieNode* right;$/;"	m	struct:BTrieNode	file:	access:public
rightSideView	.\leet_199.cc	/^    vector<int> rightSideView(TreeNode* root){$/;"	f	class:Solution	access:public	signature:(TreeNode* root)
rngSeed	.\catch.hpp	/^    unsigned int rngSeed();$/;"	p	namespace:Catch	signature:()
root	.\wap\BTrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
root	.\wap\submit\BTrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
root	.\wap\submit\wap2_sol.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
root	.\wap\submit\wap_sol1.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
root	.\wap\submit\xortrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
root	.\wap\xortrie.cc	/^		BTrieNode* root;$/;"	m	class:BTrie	file:	access:private
s	.\catch.hpp	/^        static std::ostream &s;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
s1	.\leet_173.cc	/^        stack<TreeNode*> s1;$/;"	m	class:BSTIterator	file:	access:public
score	.\wap\submit\wap_sol1.cc	/^std::vector<int> score(const int_matrix &mat, std::vector<int> &used){$/;"	f	signature:(const int_matrix &mat, std::vector<int> &used)
score	.\wap\wap1\wap_sol1.cc	/^std::vector<int> score(const int_matrix &mat, std::vector<int> &used){$/;"	f	signature:(const int_matrix &mat, std::vector<int> &used)
search	.\SurroundedRegions.cpp	/^    void search(int a, int b, int m, int n, queue<loc> &q, vector<vector<char>>& board){$/;"	f	class:Solution	access:public	signature:(int a, int b, int m, int n, queue<loc> &q, vector<vector<char>>& board)
seedRng	.\catch.hpp	/^    void seedRng( IConfig const& config );$/;"	p	namespace:Catch	signature:( IConfig const& config )
set	.\test_ptr.cc	/^void set(int* &p){$/;"	f	signature:(int* &p)
set2	.\test_ptr.cc	/^void set2(int* p){$/;"	f	signature:(int* p)
setConfig	.\catch.hpp	/^        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( Ptr<IConfig const> const& config )
setLhs	.\catch.hpp	/^        ResultBuilder& setLhs( std::string const& lhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& lhs )
setOp	.\catch.hpp	/^        ResultBuilder& setOp( std::string const& op );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& op )
setResultCapture	.\catch.hpp	/^        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IResultCapture* resultCapture )
setResultType	.\catch.hpp	/^        ResultBuilder& setResultType( ResultWas::OfType result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType result )
setResultType	.\catch.hpp	/^        ResultBuilder& setResultType( bool result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool result )
setRhs	.\catch.hpp	/^        ResultBuilder& setRhs( std::string const& rhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& rhs )
setRunner	.\catch.hpp	/^        virtual void setRunner( IRunner* runner ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IRunner* runner )
shouldContinueOnFailure	.\catch.hpp	/^    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
shouldDebugBreak	.\catch.hpp	/^        bool shouldDebugBreak() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
shouldSuppressFailure	.\catch.hpp	/^    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
sign	.\BigNum.cc	/^        int sign;$/;"	m	class:BigNum	file:	access:private
sizer	.\catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	m	struct:Catch::Detail::FalseType	access:public
sizer	.\catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	m	struct:Catch::Detail::TrueType	access:public
smallmod	.\Astar\p1.cc	/^int smallmod(int x, ll m, int k){$/;"	f	signature:(int x, ll m, int k)
solve	.\SurroundedRegions.cpp	/^    void solve(vector<vector<char>>& board){$/;"	f	class:Solution	access:public	signature:(vector<vector<char>>& board)
solveNQueens	.\leet_51.cc	/^    vector<vector<string> > solveNQueens(int n){$/;"	f	class:Solution	access:public	signature:(int n)
sortList	.\leet_148.cc	/^    ListNode* sortList(ListNode* head);$/;"	p	class:Solution	file:	access:public	signature:(ListNode* head)
startsWith	.\catch.hpp	/^    bool startsWith( std::string const& s, std::string const& prefix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& prefix )
stringmap	.\leet_290.cc	/^    typedef unordered_map<char,string> stringmap;$/;"	t	class:Solution	file:	access:public
succeeded	.\catch.hpp	/^        bool succeeded() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
swap	.\catch.hpp	/^        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr& other )
t	.\catch.hpp	/^        static T  const&t;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
testFalse	.\catch.hpp	/^            bool testFalse;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
testStreamable	.\catch.hpp	/^    FalseType testStreamable( FalseType );$/;"	p	namespace:Catch::Detail	signature:( FalseType )
testStreamable	.\catch.hpp	/^    TrueType& testStreamable( std::ostream& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream& )
throwLogicError	.\catch.hpp	/^    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );$/;"	p	namespace:Catch	signature:( std::string const& message, SourceLineInfo const& locationInfo )
toBuy	.\leet_309.cc	15;"	d	file:
toCool	.\leet_309.cc	14;"	d	file:
toLower	.\catch.hpp	/^    std::string toLower( std::string const& s );$/;"	p	namespace:Catch	signature:( std::string const& s )
toLowerInPlace	.\catch.hpp	/^    void toLowerInPlace( std::string& s );$/;"	p	namespace:Catch	signature:( std::string& s )
toSell	.\leet_309.cc	13;"	d	file:
toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	access:public	signature:() const
toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	access:public	signature:() const
toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:() const
toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:() const
toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:() const
toString	.\catch.hpp	/^            virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:() const
toString	.\catch.hpp	/^        virtual std::string toString() const = 0;$/;"	p	struct:Catch::Matchers::Impl::Matcher	access:public	signature:() const
toString	.\catch.hpp	/^    std::string toString( NSObject* const& nsObject );$/;"	p	namespace:Catch	signature:( NSObject* const& nsObject )
toString	.\catch.hpp	/^    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );$/;"	p	namespace:Catch	signature:( NSString * CATCH_ARC_STRONG const& nsstring )
toString	.\catch.hpp	/^    std::string toString( NSString const * const& nsstring );$/;"	p	namespace:Catch	signature:( NSString const * const& nsstring )
toString	.\catch.hpp	/^std::string toString( T const& value );$/;"	p	namespace:Catch	signature:( T const& value )
toString	.\catch.hpp	/^std::string toString( bool value );$/;"	p	namespace:Catch	signature:( bool value )
toString	.\catch.hpp	/^std::string toString( char value );$/;"	p	namespace:Catch	signature:( char value )
toString	.\catch.hpp	/^std::string toString( char* const value );$/;"	p	namespace:Catch	signature:( char* const value )
toString	.\catch.hpp	/^std::string toString( const char* const value );$/;"	p	namespace:Catch	signature:( const char* const value )
toString	.\catch.hpp	/^std::string toString( const double value );$/;"	p	namespace:Catch	signature:( const double value )
toString	.\catch.hpp	/^std::string toString( const float value );$/;"	p	namespace:Catch	signature:( const float value )
toString	.\catch.hpp	/^std::string toString( const wchar_t* const value );$/;"	p	namespace:Catch	signature:( const wchar_t* const value )
toString	.\catch.hpp	/^std::string toString( int value );$/;"	p	namespace:Catch	signature:( int value )
toString	.\catch.hpp	/^std::string toString( long long value );$/;"	p	namespace:Catch	signature:( long long value )
toString	.\catch.hpp	/^std::string toString( signed char value );$/;"	p	namespace:Catch	signature:( signed char value )
toString	.\catch.hpp	/^std::string toString( std::nullptr_t );$/;"	p	namespace:Catch	signature:( std::nullptr_t )
toString	.\catch.hpp	/^std::string toString( std::string const& value );$/;"	p	namespace:Catch	signature:( std::string const& value )
toString	.\catch.hpp	/^std::string toString( std::vector<T,Allocator> const& v ) {$/;"	f	namespace:Catch	signature:( std::vector<T,Allocator> const& v )
toString	.\catch.hpp	/^std::string toString( std::wstring const& value );$/;"	p	namespace:Catch	signature:( std::wstring const& value )
toString	.\catch.hpp	/^std::string toString( unsigned char value );$/;"	p	namespace:Catch	signature:( unsigned char value )
toString	.\catch.hpp	/^std::string toString( unsigned int value );$/;"	p	namespace:Catch	signature:( unsigned int value )
toString	.\catch.hpp	/^std::string toString( unsigned long long value );$/;"	p	namespace:Catch	signature:( unsigned long long value )
toString	.\catch.hpp	/^std::string toString( unsigned long value );$/;"	p	namespace:Catch	signature:( unsigned long value )
toString	.\catch.hpp	/^std::string toString( wchar_t* const value );$/;"	p	namespace:Catch	signature:( wchar_t* const value )
toStringSuffix	.\catch.hpp	/^            std::string toStringSuffix() const$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	access:public	signature:() const
trim	.\catch.hpp	/^    std::string trim( std::string const& str );$/;"	p	namespace:Catch	signature:( std::string const& str )
trueValue	.\catch.hpp	/^        void trueValue() const {}$/;"	f	class:Catch::SafeBool	access:private	signature:() const
useActiveException	.\catch.hpp	/^        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal )
val	.\BST.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
val	.\Min_Dep_BTree.cpp	/^  int val;$/;"	m	struct:TreeNode	file:	access:public
val	.\leet_144.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
val	.\leet_148.cc	/^    int val;$/;"	m	struct:ListNode	file:	access:public
val	.\leet_173.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
val	.\leet_199.cc	/^    int val;$/;"	m	struct:TreeNode	file:	access:public
value	.\catch.hpp	/^        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon1
vec	.\wap\BTrie.cc	/^typedef std::vector<int> vec;$/;"	t	file:
vec	.\wap\submit\BTrie.cc	/^typedef std::vector<int> vec;$/;"	t	file:
vec	.\wap\submit\wap_sol1.cc	/^typedef std::vector<int> vec;$/;"	t	file:
wordPattern	.\leet_290.cc	/^    bool wordPattern(string pattern, string str) {$/;"	f	class:Solution	access:public	signature:(string pattern, string str)
ycm_core	.\.ycm_extra_conf.py	/^import ycm_core$/;"	i
~AssertionResult	.\catch.hpp	/^        ~AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
~AutoReg	.\catch.hpp	/^    ~AutoReg();$/;"	p	struct:Catch::AutoReg	access:public	signature:()
~BTrie	.\wap\BTrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
~BTrie	.\wap\submit\BTrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
~BTrie	.\wap\submit\wap2_sol.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
~BTrie	.\wap\submit\wap_sol1.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
~BTrie	.\wap\submit\xortrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
~BTrie	.\wap\xortrie.cc	/^		~BTrie(){$/;"	f	class:BTrie	access:public	signature:()
~Contains	.\catch.hpp	/^            virtual ~Contains();$/;"	p	struct:Catch::Matchers::Impl::StdString::Contains	access:public	signature:()
~EndsWith	.\catch.hpp	/^            virtual ~EndsWith();$/;"	p	struct:Catch::Matchers::Impl::StdString::EndsWith	access:public	signature:()
~Equals	.\catch.hpp	/^            virtual ~Equals();$/;"	p	struct:Catch::Matchers::Impl::StdString::Equals	access:public	signature:()
~IContext	.\catch.hpp	/^        virtual ~IContext();$/;"	p	struct:Catch::IContext	access:public	signature:()
~IGeneratorInfo	.\catch.hpp	/^        virtual ~IGeneratorInfo();$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
~IGeneratorsForTest	.\catch.hpp	/^        virtual ~IGeneratorsForTest();$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
~IMutableContext	.\catch.hpp	/^        virtual ~IMutableContext();$/;"	p	struct:Catch::IMutableContext	access:public	signature:()
~IShared	.\catch.hpp	/^        virtual ~IShared();$/;"	p	struct:Catch::IShared	access:public	signature:()
~ITestCase	.\catch.hpp	/^        virtual ~ITestCase();$/;"	p	struct:Catch::ITestCase	access:protected	signature:()
~ITestCaseRegistry	.\catch.hpp	/^        virtual ~ITestCaseRegistry();$/;"	p	struct:Catch::ITestCaseRegistry	access:public	signature:()
~Matcher	.\catch.hpp	/^        virtual ~Matcher() {}$/;"	f	struct:Catch::Matchers::Impl::Matcher	access:public	signature:()
~MethodTestCase	.\catch.hpp	/^    virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase	access:private	signature:()
~NonCopyable	.\catch.hpp	/^        virtual ~NonCopyable();$/;"	p	class:Catch::NonCopyable	access:protected	signature:()
~Ptr	.\catch.hpp	/^        ~Ptr(){$/;"	f	class:Catch::Ptr	access:public	signature:()
~StartsWith	.\catch.hpp	/^            virtual ~StartsWith();$/;"	p	struct:Catch::Matchers::Impl::StdString::StartsWith	access:public	signature:()
